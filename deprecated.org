#+title: Archive for deprecated Emacs config components
#+author: matheuristic

* Notes

This file contains Emacs configuration components that were used but
removed as they were not needed or deprecated in favor of updated
packages or code.

* Backward compatibility

In Emacs versions before 27, we should load the ~early-init.el~ file explicitly in ~init.el~.

#+name: early-init-pre-27
#+begin_src emacs-lisp
;; backwards-compatibility code for Emacs versions <27
(when (version< emacs-version "27")
  ;; load early-initialization file ~/.emacs.d/early-init.el
  ;; Emacs 27+ automatically loads this file before rendering UI elements
  (let ((local-f (expand-file-name "early-init.el" user-emacs-directory)))
    (when (file-exists-p local-f) (load-file local-f))))
#+end_src

* Backend and frontend frameworks for building user interfaces

** Company front-end with icons                                       :melpa:

[[https://github.com/sebastiencs/company-box][company-box]] provides a fancy front-end for Company with icons.

#+name: company-box
#+begin_src emacs-lisp
(use-package company-box
  :hook (company-mode . company-box-mode))
#+end_src

** Hydra                                              :semiearly:melpa:hydra:

*Note*: Deprecated for this configuration. Transitioning to transient
to reduce maintenance overhead (mostly due to the difficulty of
maintaining complex docstrings).

[[https://github.com/abo-abo/hydra][Hydra]] is a framework for surfacing temporary bindings with visual
help.

Temporary bindings are defined using ~defhydra~.
They are not bound by default on creation, and need to be explicitly
given a binding (for example, using ~define-key~) for easy invocation.

Hydra bindings and definitions in this configuration adhere to the
following conventions:
- Globally-accessible hydras are always bound to a key sequence
  prefixed by ~C-c C-M-~ (like ~C-c C-M-b~ for the basic buffer
  management hydra).
- Major mode-specific hydras are always bound to ~C-c C-M-m~.
- A hydra always has a ~q~ head that quits the hydra, except when the
  user is expected to type normally while the hydra is active
  (for example, the [[Multiple cursors hydra][multiple cursors hydra]]).

For ease of reference, hydra colors are mapped to the following
behavior (copied from [[https://github.com/abo-abo/hydra/wiki/Hydra-Colors][here]]):

| Body color | Head color | Executing NON-HEADS   | Executing HEADS |
|------------+------------+-----------------------+-----------------|
| amaranth   | red        | Disallow and Continue | Continue        |
| teal       | blue       | Disallow and Continue | Quit            |
| pink       | red        | Allow and Continue    | Continue        |
| red        | red        | Allow and Quit        | Continue        |
| blue       | blue       | Allow and Quit        | Quit            |

The ~:demand t~ keyword is used to make sure the package is loaded and
the ~defhydra~ macro immediately available when the block is
processed.

#+name: hydra
#+begin_src emacs-lisp
;; framework for defining temporary, repeatable bindings
;; see https://github.com/abo-abo/hydra
(use-package hydra
  :demand t)
#+end_src

** Helm                                                               :melpa:

[[https://github.com/emacs-helm/helm][Helm]] is a framework for incremental completions and narrowing
selections, in other words an alternative for Icomplete.

It is much heavier but more featureful.

In most instances, use only this or Icomplete but not both.

*Configuration*:
- Rebind standard Emacs commands that use completion like ~find-files~
  to helm equivalents.
- ~<tab>~ key triggers completion rather than action, which is closer
  to standard Emacs minibuffer behavior and that of most shells.

#+name: helm
#+begin_src emacs-lisp
(use-package helm
  :init
  (setq helm-allow-mouse t
        helm-command-prefix-key "C-c C-M-h"
        helm-prevent-escaping-from-minibuffer nil
        ;; show helm completion buffer using default display function
        ;; instead of always opening a new frame for it
        helm-show-completion-display-function #'helm-show-completion-default-display-function
        ;; show helm buffers by splitting current window instead of
        ;; taking over another window in multi-window layout
        helm-split-window-inside-p t)
  (when (version< emacs-version "27")
    (add-to-list 'completion-styles 'helm-flex t))
  :config
  (require 'helm-config)
  (helm-mode 1)
  (helm-autoresize-mode 1)
  ;; bind over the standard Emacs commands
  (define-key global-map [remap find-file] 'helm-find-files)
  (define-key global-map [remap occur] 'helm-occur)
  ;; (define-key global-map [remap list-buffers] 'helm-buffers-list)
  ;; (define-key global-map [remap switch-to-buffer] 'helm-mini)
  (define-key global-map [remap switch-to-buffer] 'helm-buffers-list)
  (define-key global-map [remap dabbrev-expand] 'helm-dabbrev)
  (define-key global-map [remap execute-extended-command] 'helm-M-x)
  (define-key global-map [remap apropos-command] 'helm-apropos)
  ;; make <tab> only complete names during helm completion, instead of
  ;; default behavior that creates new buffer on the second press
  ;; after which a third press kills the newly created buffer
  (setq helm-ff-kill-or-find-buffer-fname-fn #'ignore)
  (define-key helm-map (kbd "TAB") #'helm-execute-persistent-action)
  (define-key helm-map (kbd "<tab>") #'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-i") #'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-z") #'helm-select-action))
#+end_src

*** Use icons in Helm                                                 :melpa:

[[https://github.com/yyoncho/helm-icons][helm-icons]] shows file icons using those from Treemacs when using
file-related Helm commands.

#+name: helm-icons
#+begin_src emacs-lisp
(use-package helm-icons
  :after helm
  :config (helm-icons-enable))
#+end_src

** Selectrum for minibuffer narrowing and selection                   :melpa:

[[https://github.com/raxod502/selectrum][Selectrum]] provides a `completing-read' interface with incremental
narrowing. Other similar packages include [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Icomplete.html][Icomplete]], [[https://github.com/abo-abo/swiper#ivy][Ivy]], [[https://github.com/emacs-helm/helm][Helm]],
[[https://www.emacswiki.org/emacs/Icicles][Icicles]], etc.

#+name: selectrum
#+begin_src emacs-lisp
;; incremental narrowing interface for `completing-read'
(use-package selectrum
  :init (setq selectrum-count-style 'current/matches
              selectrum-extend-current-candidate-highlight t)
  :config (selectrum-mode 1))
#+end_src

** Sorting and filtering candidates with prescient.el                 :melpa:

[[https://github.com/raxod502/prescient.el][prescient.el]] is a library for sorting and filtering lists, like [[https://github.com/lewang/flx][flx]].
If ~prescient-persist-mode~ is enabled it also saves usage statistics
across Emacs sessions to be used in sorting, like [[https://github.com/DarwinAwardWinner/amx][amx]], [[https://github.com/PythonNut/historian.el][historian.el]]
and [[https://github.com/company-mode/company-statistics][company-statistics]].

Integrations are available for other packages like Selectrum and
Company as separate packages in MELPA.

#+name: prescient
#+begin_src emacs-lisp
;; library for sorting and filtering
(use-package prescient
  :init (setq prescient-filter-method '(literal regexp initialism)
              prescient-sort-length-enable t)
  :config (prescient-persist-mode 1)) ; persist usage cache between sessions
#+end_src

*** prescient.el integration with Selectrum                           :melpa:

Integrate prescient.el with Selectrum.

#+name: selectrum-prescient
#+begin_src emacs-lisp
;; prescient.el integration with Selectrum
(use-package selectrum-prescient
  :after (prescient selectrum)
  :config (selectrum-prescient-mode 1))
#+end_src

*** prescient.el integration with Company                             :melpa:

Integrate prescient.el with Company.

#+name: company-prescient
#+begin_src emacs-lisp
;; prescient.el integration with Company
(use-package company-prescient
  :after (prescient company)
  :config (company-prescient-mode 1))
#+end_src

* Bookmarks and history

** Recent files

*** Helm recentf

Prefer ~helm-recentf~ to ~recentf-open-files~ for the main binding.

#+name: helm-recentf
#+begin_src emacs-lisp
;; prefer helm-recentf to recentf-open-files
(add-hook 'after-init-hook
          (lambda ()
            (when (featurep 'helm)
              (define-key global-map [remap recentf-open-files]
                'helm-recentf))))
#+end_src

** Bookmarks hydra                                                    :hydra:

Hydra for easier [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Bookmarks.html][bookmark]] manipulation and usage.

#+name: bookmarks-hydra
#+begin_src emacs-lisp
(defhydra my-hydra/bookmarks (:color teal :columns 3)
  "
Bookmarks (_q_: quit)"
  ("q" nil nil)
  ("s" bookmark-set "set")
  ("d" bookmark-delete "delete")
  ("l" list-bookmarks "list")
  ("j" bookmark-jump "jump")
  ("i" bookmark-insert "insert")
  ("I" bookmark-insert-location "insert-loc")
  ("L" bookmark-load "load")
  ("W" bookmark-write "write"))
(global-set-key (kbd "C-c C-M-j") 'my-hydra/bookmarks/body)
#+end_src

* Buffers, windows, frames, workspaces

** Buffer management

*** Bury scratch and message buffer instead of killing them

Make ~*scratch*~ and ~*Message*~ buffers unkillable, burying the
buffers instead when the user tries to delete them.

#+name: bury-not-kill-buffers
#+begin_src emacs-lisp
;; bury these buffers on kill command instead of killing them
(setq my-unkillable-buffers '("*scratch*"
                              "*Messages*"))
(defun my-bury-unkillable-buffers ()
  "Buries the current buffer if it is unkillable, otherwise return t."
  (if (member (buffer-name) my-unkillable-buffers)
      (progn
        (bury-buffer)
        nil)
    t))
(add-hook 'kill-buffer-query-functions #'my-bury-unkillable-buffers)
#+end_src

*** better-jumper to maintain and traverse jump-lists                 :melpa:

[[https://github.com/gilbertw1/better-jumper][better-jumper]] is a jump-list implementation useful for automatically
building file jump lists and moving backwards and forwards through it.

#+name: better-jumper
#+begin_src emacs-lisp
;; jump list implementation
(use-package better-jumper
  :config
  (better-jumper-mode 1)
  ;; manage marker stack with better-jumper instead of the default
  (advice-add #'xref-push-marker-stack :around #'better-jumper-set-jump)
  (global-set-key [remap xref-pop-marker-stack]
                  #'better-jumper-jump-backward))
#+end_src

**** Add better-jumper calls to buffer hydra

#+name: add-better-jumper-to-buffer-hydra
#+begin_src emacs-lisp
;; add better-jumper calls to buffer hydra
(defhydra+ my-hydra/buffer nil
  ("," better-jumper-jump-backward "jump-bwd")
  ("." better-jumper-jump-forward "jump-fwd"))
#+end_src

*** Buffer manipulation hydra                                         :hydra:

Hydra for basic [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Buffers.html][buffer]] manipulation.

#+name: buffer-hydra
#+begin_src emacs-lisp
;; hydra for basic buffer management
(defhydra my-hydra/buffer (:color amaranth :columns 4)
  "
Buffer (_q_: quit)"
  ("q" nil nil :exit t)
  ("b" switch-to-buffer "switch" :exit t)
  ("p" previous-buffer "previous")
  ("n" next-buffer "next")
  ("R" revert-buffer "revert")
  ("B" bury-buffer "bury")
  ("U" unbury-buffer "unbury")
  ("s" save-buffer "save")
  ("S" save-some-buffers "save-all") ;; call with "1 S" to save all
  ("k" kill-this-buffer "kill")
  ("K" kill-matching-buffers "kill-match")
  ("t" (lambda ()
         (interactive)
         (when (y-or-n-p "Cleanup all TRAMP buffers and connections? ")
           (tramp-cleanup-all-buffers)))
   "tramp-cleanup" :exit t))
(global-set-key (kbd "C-c C-M-b") 'my-hydra/buffer/body)
#+end_src

*** Kill all other buffers

Kill buffers other than the current one.

#+name: my-kill-other-buffers
#+begin_src emacs-lisp
(defun my-kill-other-buffers ()
  "Kill all file buffers except the current one."
  (interactive)
  (when (y-or-n-p "Kill all file buffers except the current one? ")
    (seq-each
     #'kill-buffer
     (delete (current-buffer)
             (seq-filter #'buffer-file-name (buffer-list))))))
#+end_src

**** Add my-kill-other-buffers to buffer hydra                        :hydra:

#+name: add-my-kill-other-buffers-to-buffer-hydra
#+begin_src emacs-lisp
;; add my-kill-other-buffers to buffer hydra
(defhydra+ my-hydra/buffer nil
  ("o" my-kill-other-buffers "only" :exit t))
#+end_src

*** Buffer cleanup hydra                                              :hydra:

Buffer cleanup hydra, configured as a subhydra for the buffer hydra.

#+name: buffer-cleanup-hydra
#+begin_src emacs-lisp
;; cleanup hydra
(defhydra my-hydra/buffer/cleanup (:color amaranth :columns 3)
  "
Buffer → Cleanup (_q_: ←)"
  ("q" my-hydra/buffer/body nil :exit t)
  ("r" whitespace-report "whitespace-report" :exit t)
  ("w" whitespace-cleanup "whitespace-cleanup")
  ("i" (lambda ()
         "Indent a selected region, or the buffer otherwise."
         (interactive)
         (cond
          ((use-region-p) (indent-region (region-beginning) (region-end)))
          (t (indent-region (point-min) (point-max)))))
   "indent")
  ("t" (lambda ()
         "Indent a selected region, or the buffer otherwise."
         (interactive)
         (cond
          ((use-region-p) (untabify (region-beginning) (region-end)))
          (t (untabify (point-min) (point-max)))))
   "untabify"))

;; add entry point to cleanup hydra to buffer hydra
(defhydra+ my-hydra/buffer nil
  ("C" my-hydra/buffer/cleanup/body "→ Cleanup" :exit t))
#+end_src

*** Advanced buffer management with Ibuffer

**** Ibuffer hydra                                                    :hydra:

Major mode-specific hydra for Ibuffer.

#+name: ibuffer-hydra
#+begin_src emacs-lisp
;; hydras for Ibuffer commands
;; adapted from https://github.com/abo-abo/hydra/wiki/Ibuffer
(defhydra my-hydra/ibuffer-mode (:color amaranth :columns 3)
  "
Ibuffer (_q_: quit)"
  ("q" nil nil :exit t)
  ;; navigation
  ("n" ibuffer-forward-line "next")
  ("p" ibuffer-backward-line "prev")
  ("RET" (condition-case nil
             (progn (ibuffer-toggle-filter-group)
                    (my-hydra/ibuffer-mode/body))
           (error (ibuffer-visit-buffer))) "open" :exit t)
  ;; mark
  ("m" ibuffer-mark-forward "mark")
  ("u" ibuffer-unmark-forward "unmark")
  ("*" my-hydra/ibuffer-mode/mark/body "→ Mark" :exit t)
  ;; actions
  ("S" ibuffer-do-save "save")
  ("D" ibuffer-do-delete "delete")
  ("a" my-hydra/ibuffer-mode/action/body "→ Action" :exit t)
  ;; view
  ("`" ibuffer-switch-format "format")
  ("g" ibuffer-update "refresh")
  ("s" my-hydra/ibuffer-mode/sort/body "→ Sort" :exit t)
  ("/" my-hydra/ibuffer-mode/filter/body "→ Filter" :exit t)
  ;; other
  ("o" ibuffer-visit-buffer-other-window "open-other" :exit t))
(defhydra my-hydra/ibuffer-mode/mark (:color amaranth :columns 5
                                      :after-exit (my-hydra/ibuffer-mode/body))
  "
Ibuffer → Mark (_q_: ←)"
  ("q" nil nil :exit t)
  ("*" ibuffer-unmark-all "unmark all")
  ("M" ibuffer-mark-by-mode "mode")
  ("m" ibuffer-mark-modified-buffers "modified")
  ("u" ibuffer-mark-unsaved-buffers "unsaved")
  ("s" ibuffer-mark-special-buffers "special")
  ("r" ibuffer-mark-read-only-buffers "read-only")
  ("/" ibuffer-mark-dired-buffers "dired")
  ("e" ibuffer-mark-dissociated-buffers "dissociated")
  ("h" ibuffer-mark-help-buffers "help")
  ("z" ibuffer-mark-compressed-file-buffers "compressed"))
(defhydra my-hydra/ibuffer-mode/action (:color teal :columns 3
                                        :after-exit (if (eq major-mode 'ibuffer-mode)
                                                        (my-hydra/ibuffer-mode/body)))
  "
Ibuffer → Action (_q_: ←)"
  ("q" nil nil)
  ("A" ibuffer-do-view "view")
  ("E" ibuffer-do-eval "eval")
  ("F" ibuffer-do-shell-command-file "shell-command-file")
  ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
  ("H" ibuffer-do-view-other-frame "view-other-frame")
  ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
  ("M" ibuffer-do-toggle-modified "toggle-modified")
  ("O" ibuffer-do-occur "occur")
  ("P" ibuffer-do-print "print")
  ("Q" ibuffer-do-query-replace "query-replace")
  ("R" ibuffer-do-rename-uniquely "rename-uniquely")
  ("T" ibuffer-do-toggle-read-only "toggle-read-only")
  ("U" ibuffer-do-replace-regexp "replace-regexp")
  ("V" ibuffer-do-revert "revert")
  ("W" ibuffer-do-view-and-eval "view-and-eval")
  ("X" ibuffer-do-shell-command-pipe "shell-command-pipe"))
(defhydra my-hydra/ibuffer-mode/sort (:color amaranth :columns 5)
  "
Ibuffer → Sort (_q_: ←)"
  ("q" my-hydra/ibuffer-mode/body nil :exit t)
  ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
  ("f" ibuffer-do-sort-by-filename/process "filename")
  ("m" ibuffer-do-sort-by-major-mode "mode")
  ("s" ibuffer-do-sort-by-size "size")
  ("v" ibuffer-do-sort-by-recency "recency")
  ("i" ibuffer-invert-sorting "invert"))
(defhydra my-hydra/ibuffer-mode/filter (:color amaranth :columns 5
                                        :pre (require 'ibuffer-vc))
  "
Ibuffer → Filter (_q_: ←)"
  ("q" my-hydra/ibuffer-mode/body nil :exit t)
  ("a" ibuffer-add-saved-filters "add-saved")
  ("c" ibuffer-filter-by-content "content")
  ("e" ibuffer-filter-by-predicate "predicate")
  ("f" ibuffer-filter-by-filename "filename")
  ("m" ibuffer-filter-by-used-mode "mode")
  ("M" ibuffer-filter-by-derived-mode "derived mode")
  ("n" ibuffer-filter-by-name "name")
  ("p" ibuffer-pop-filter "pop")
  (">" ibuffer-filter-by-size-gt "size-gt")
  ("<" ibuffer-filter-by-size-lt "size-lt")
  ("&" ibuffer-and-filter "and")
  ("|" ibuffer-or-filter "or")
  ("V" ibuffer-vc-set-filter-groups-by-vc-root "vc-groups")
  ("R" ibuffer-switch-to-saved-filter-groups "saved-groups")
  ("\\" ibuffer-clear-filter-groups "clear-groups")
  ("/" ibuffer-filter-disable "disable"))

;; bind Ibuffer hydra
(with-eval-after-load 'ibuffer
  (define-key ibuffer-mode-map (kbd "C-c C-M-m") #'my-hydra/ibuffer-mode/body))
#+end_src

*** Fast buffer switching with nswbuff                                :melpa:

[[https://github.com/joostkremers/nswbuff][nswbuff]] allows for quick switching between open buffers.

It can be configured to integrate with Projectile to only switch
between between those buffers associated with the current project.

#+name: nswbuff
#+begin_src emacs-lisp
;; quick buffer switching (configured to be within a project)
(use-package nswbuff
  :after projectile
  :bind (("<C-tab>" . nswbuff-switch-to-next-buffer)
         ("<C-S-tab>" . nswbuff-switch-to-previous-buffer)
         ;; see https://emacs.stackexchange.com/questions/53461/specifying-a-binding-for-control-shift-tab
         ("<C-S-iso-lefttab>" . nswbuff-switch-to-previous-buffer))
  :init
  (setq nswbuff-buffer-list-function #'nswbuff-projectile-buffer-list
        nswbuff-clear-delay 2
        nswbuff-display-intermediate-buffers t
        ;; exclude all internal buffers from the nswbuff switch list
        nswbuff-exclude-buffer-regexps '("^ "
                                         "^\\*.*\\*"
                                         "org-src-fontification")
        nswbuff-exclude-mode-regexp (mapconcat
                                     'identity
                                     '("dired-mode"
                                       "gnus-mode")
                                     "\\|")
        nswbuff-start-with-current-centered nil)
  :config
  ;; unbind C-tab in org-mode to not conflict with nswbuff global binding
  (with-eval-after-load 'org
    (unbind-key "<C-tab>" org-mode-map)))
#+end_src

*** Advanced buffer management with Ibuffer

**** Ibuffer icons                                                    :melpa:

Add file icons next to the file names.
Uses file icon API exposed by the ~all-the-icons~ package.

#+name: all-the-icons-ibuffer
#+begin_src emacs-lisp
;; use font icons in Ibuffer
(when (display-graphic-p)
  (use-package all-the-icons-ibuffer
    :after (all-the-icons ibuffer)
    :config (all-the-icons-ibuffer-mode 1)))
#+end_src

** Window management

*** Window management hydra                                           :hydra:

Hydra for [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Windows.html][window]] (panes) management.

*Note*: In Emacs 27+, ~next-multiframe-window~ and
~previous-multiframe-window~ were renamed to ~next-window-any-frame~
and ~previous-window-any-frame~, and the new names are used here.

#+name: window-hydra
#+begin_src emacs-lisp
(defhydra my-hydra/window (:color amaranth :columns 3)
  "
Window (_q_: quit)"
  ("q" nil nil :exit t)
  ("u" winner-undo "winner-undo")
  ("r" winner-redo "winner-redo")
  ("n" (condition-case nil
           (next-window-any-frame)
         (error (next-multiframe-window)))
   "next")
  ("p" (condition-case nil
           (previous-window-any-frame)
         (error (previous-multiframe-window)))
   "previous")
  ("v" split-window-right "split-v")
  ("s" split-window-below "split-h")
  ("<left>" windmove-left "left")
  ("<down>" windmove-down "down")
  ("<up>" windmove-up "up")
  ("<right>" windmove-right "right")
  ("S-<left>" (my-transpose-windows 'windmove-left) "transpose-l")
  ("S-<down>" (my-transpose-windows 'windmove-down) "transpose-d")
  ("S-<up>" (my-transpose-windows 'windmove-up) "transpose-u")
  ("S-<right>" (my-transpose-windows 'windmove-right) "transpose-r")
  ("-" shrink-window "shrink-v")
  ("+" enlarge-window "enlarge-v")
  ("<" shrink-window-horizontally "shrink-h")
  (">" enlarge-window-horizontally "enlarge-h")
  ("M" minimize-window "minimize")
  ("m" maximize-window "maximize")
  ("=" balance-windows "balance")
  ("_" balance-windows-area "balance-area")
  ("o" delete-other-windows "only")
  ("d" delete-window "delete")
  ("D" kill-buffer-and-window "delete-buf"))
(global-set-key (kbd "C-c C-M-w") 'my-hydra/window/body)
#+end_src

**** Window management helper functions

Helper functions for the frame management hydra.

#+name: window-hydra-helper-functions
#+begin_src emacs-lisp
(defun my-transpose-windows (selector)
  "Call SELECTOR and transpose buffers between current and selected windows."
  (let ((from-win (selected-window))
        (from-buf (window-buffer)))
    (funcall selector)
    (set-window-buffer from-win (window-buffer))
    (set-window-buffer (selected-window) from-buf)))
#+end_src

*** Add buffer rotation across windows to window management hydra     :hydra:

Define a function to rotate buffers across the windows of a frame, and
add an entrypoint to the function in the window management hydra.

#+name: rotate-window-buffers-hydra
#+begin_src emacs-lisp
(defun rotate-window-buffers (rotations)
  "Rotate buffers in the windows of the current frame ROTATIONS times.
ROTATIONS can be negative, which rotates in the opposite direction."
  (interactive "P")
  (let ((num-windows (count-windows)))
    (if (not (> num-windows 1))
        (message "Only one window in the frame. Nothing to rotate.")
      (let* ((windows (window-list))
             ;; original window order properties
             (window-props (mapcar (lambda (w)
                                     `(:buffer ,(window-buffer w)
                                       :start ,(window-start w)
                                       :point ,(window-point w)))
                                   windows))
             ;; new window order after rotation
             (window-moves (mapcar
                            (lambda (k)
                              (elt windows (mod (+ k rotations) num-windows)))
                            (number-sequence 0 (1- num-windows))))
             ;; create alist for easier looping later
             (wins-props (cl-mapcar #'cons window-moves window-props)))
        ;; iteratively assign orig window props in new window order
        (dolist (w-p wins-props)
          (let ((win (car w-p))
                (prop (cdr w-p)))
            (set-window-buffer-start-and-point
             win
             (plist-get prop :buffer)
             (plist-get prop :start)
             (plist-get prop :point))))))))

;; add entrypoint for `rotate-window-buffers' to window management hydra
(defhydra+ my-hydra/window nil
  ("," (lambda (n) (interactive "p") (rotate-window-buffers (- n))) "rotate-l")
  ("." (lambda (n) (interactive "p") (rotate-window-buffers n)) "rotate-r"))
#+end_src

*** ace-window

[[https://github.com/abo-abo/ace-window][ace-window]] provides window navigation and manipulation functions.

#+name: ace-window
#+begin_src emacs-lisp
;; window navigation and management
(use-package ace-window
  :config
  (setq aw-background t
        aw-char-position 'top-left
        aw-ignore-current nil
        aw-scope 'frame)
  (global-set-key (kbd "M-o") #'ace-window))
#+end_src

**** Add ace-window entry point to window hydra

Add entry point for calling ~ace-window~ to the window hydra.

#+name: add-ace-window-to-window-hydra
#+begin_src emacs-lisp
;; add `ace-window' entry point to window hydra
(defhydra+ my-hydra/window nil
  ("a" ace-window "ace-window"))
#+end_src

*** popwin for automatic management of special buffers                :melpa:

[[https://github.com/emacsorphanage/popwin][popwin]] configures Emacs to show special buffers like ~*Help*~,
~*Completions*~ and so on in a window that automatically gets closed
on ~C-g~ or selection of another window.

It can also be used to popup temporary buffers, and that functionality
can be accessed through ~popwin:keymap~ which is configured to
the ~C-z~ prefix (use ~C-x C-z~ to call ~suspend-frame~ instead).

#+name: popwin
#+begin_src emacs-lisp
;; popup window manager, also auto-closes special buffers like
;; *compilation* and *Completions*
(use-package popwin
  :config
  (popwin-mode 1)
  (global-set-key (kbd "C-z") popwin:keymap))
#+end_src

** Frame management

*** Frame management hydra                                            :hydra:

Hydra for easier [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Frames.html][frame]] (application window) management.

#+name: frame-hydra
#+begin_src emacs-lisp
(defhydra my-hydra/frame (:color amaranth :columns 4)
  "
Frame (_q_: quit)"
  ("q" nil nil :exit t)
  ("<up>" (lambda (n) (interactive "p") (my-move-frame-pct 0 (- n))) "move-u")
  ("<down>" (lambda (n) (interactive "p") (my-move-frame-pct 0 n)) "move-d")
  ("<left>" (lambda (n) (interactive "p") (my-move-frame-pct (- n) 0)) "move-l")
  ("<right>" (lambda (n) (interactive "p") (my-move-frame-pct n 0)) "move-r")
  ("+" (lambda (n) (interactive "p") (my-enlarge-frame 0 n)) "enlarge-v")
  ("-" (lambda (n) (interactive "p") (my-enlarge-frame 0 (- n))) "shrink-v")
  (">" (lambda (n) (interactive "p") (my-enlarge-frame n 0)) "enlarge-h")
  ("<" (lambda (n) (interactive "p") (my-enlarge-frame (- n) 0)) "shrink-h")
  ("M" toggle-frame-maximized "maximize")
  ("f" toggle-frame-fullscreen "fullscreen")
  ("p" (other-frame -1) "previous")
  ("n" other-frame "next")
  ("s" select-frame-by-name "select")
  ("m" (lambda () (interactive) (my-make-frame 15 20)) "make")
  ("d" delete-frame "delete")
  ("o" delete-other-frames "only"))
(global-set-key (kbd "C-c C-M-f") 'my-hydra/frame/body)
#+end_src

**** Frame management helper functions

Helper functions for the frame management hydra.

#+name: frame-hydra-helper-functions
#+begin_src emacs-lisp
(defun my-enlarge-frame (w h)
  "Enlarge width, height of selected frame by W, H lines (shrink if negative)."
  (let ((this-frame (selected-frame)))
    (set-frame-width this-frame (+ (frame-width this-frame) w))
    (set-frame-height this-frame (+ (frame-height this-frame) h))))

(defun my-move-frame (x y)
  "Move selected frame by X pixels horizontally and Y pixels vertically."
  (let* ((this-frame (selected-frame))
         (fpos (frame-position this-frame)))
    (set-frame-position this-frame (+ (car fpos) x) (+ (cdr fpos) y))))

(defun my-move-frame-pct (x y)
  "Move selected frame within display by X% horizontally and Y% vertically."
  (my-move-frame (* x (/ (x-display-pixel-width) 100))
                 (* y (/ (x-display-pixel-height) 100))))

(defun my-make-frame (x y)
  "Make new frame, offset by X pixels horizontally and Y pixels vertically."
  (let ((cur-pos (frame-position)))
    (select-frame (make-frame (list (cons 'left (+ x (car cur-pos)))
                                    (cons 'top (+ y (cdr cur-pos))))))))
#+end_src

*** transpose-frame for rotating frames

**** Add transpose-frame rotation functions to frame management hydra :hydra:

Add entrypoints to ~transpose-frame~ frame rotation functions to the
frame maangement hydra.

#+name: transpose-frame-hydra
#+begin_src emacs-lisp
;; add entrypoint for transpose-frame to frame management hydra
(defhydra+ my-hydra/frame nil
  ("," (lambda (n) (interactive "p") (dotimes (_ n) (rotate-frame-anticlockwise))) "rotate-l")
  ("." (lambda (n) (interactive "p") (dotimes (_ n) (rotate-frame-clockwise))) "rotate-r"))
#+end_src

** Workspace management

*** Workspace hydra                                                   :hydra:

Hydra for workspace manipulation and usage.

#+name: workspace-hydra
#+begin_src emacs-lisp
;; hydra for workspace management
(defhydra my-hydra/workspace (:color teal :columns 3)
  "
Emacs workspace (_q_: quit)"
  ("q" nil nil)
  ("dc" desktop-clear "desktop-clear")
  ("ds" desktop-save "desktop-save")
  ("dr" desktop-read "desktop-read")
  ("dR" desktop-revert "desktop-revert")
  ("dd" desktop-change-dir "desktop-dir"))

;; binding for workspace management hydra
(global-set-key (kbd "C-c C-M-e") 'my-hydra/workspace/body)
#+end_src

* Command line interaction

** Eshell

*** Helm completion in Eshell

Extend [[https://github.com/emacs-mirror/emacs/blob/master/lisp/pcomplete.el][pcomplete]] ([[https://www.masteringemacs.org/article/pcomplete-context-sensitive-completion-emacs][more info]]) to complete commands and files in Eshell
using Helm, adapted from the [[https://github.com/emacs-helm/helm/wiki/Eshell][Helm wiki]].

#+name: helm-eshell-completion
#+begin_src emacs-lisp
(when (featurep 'helm)
  (add-hook 'eshell-mode-hook
            (lambda ()
              (eshell-cmpl-initialize)
              (define-key eshell-mode-map [remap eshell-pcomplete] 'helm-esh-pcomplete)
              (define-key eshell-mode-map (kbd "M-r") 'helm-eshell-history))))
#+end_src

*** Helm Fish Completion of CLI options in Eshell            :external:melpa:

[[https://github.com/emacs-helm/helm-fish-completion][Helm Fish Completion]] provides a Helm-based extension of [[https://github.com/emacs-mirror/emacs/blob/master/lisp/pcomplete.el][pcomplete]] to
complete CLI options using [[https://fishshell.com/][fish]] in Eshell and other shells.

If using this, ~fish-completion-mode~ should be disabled.

#+name: helm-fish-completion
#+begin_src emacs-lisp
(when (and (executable-find "fish") (featurep 'helm))
  (use-package helm-fish-completion
    :config
    (setq helm-esh-pcomplete-build-source-fn
          #'helm-fish-completion-make-eshell-source)
    (with-eval-after-load 'shell
      (define-key shell-mode-map (kbd "<tab>") #'helm-fish-completion))
    (add-hook 'eshell-mode-hook
              (lambda ()
                (define-key eshell-mode-map (kbd "<tab>")
                  #'helm-fish-completion)))))
#+end_src

** Shell entry point hydra

Hydra providing entry points into Eshell and vterm.

#+name: shell-hydra
#+begin_src emacs-lisp
;; hydra providing entry points into shell tools
(defhydra my-hydra/shell (:color teal :columns 3)
  "
Shell tools (_q_: quit)"
  ("q" nil nil)
  ("v" vterm "vterm")
  ("V" vterm-other-window "vterm-other")
  ("C-v" vterm-switchb "vterm-switchb")
  ("e" my-eshell-with-name "eshell")
  ("t" tmux-send "tmux-send")
  ("T" tmux-resend "tmux-resend"))

;; binding for spawning or switching to a named Eshell buffer
(global-set-key (kbd "C-c C-M-t") #'my-hydra/shell/body)
#+end_src

** Command interpreters for other shells

*** Term hydra                                                        :hydra:

Major mode-specific hydra for [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Terminal-emulator.html][term-mode]] for toggling between char mode
(mostly similar to a regular terminal emulator) and line mode (which
acts like [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Shell-Mode.html#Shell-Mode][Shell mode]]).

#+name: term-mode-hydra
#+begin_src emacs-lisp
;; hydra for term-mode for toggling between char and line modes
(defhydra my-hydra/term-mode (:color amaranth :columns 4)
  "
Term (_q_: quit)"
  ("q" nil nil :exit t)
  ("m" (lambda () (interactive)
         (if (term-in-line-mode)
             (progn (term-char-mode) (message "line → char"))
           (progn (term-line-mode) (message "char → line")))) "toggle-mode"))
;; bindings
(with-eval-after-load 'term
  (define-key term-mode-map (kbd "C-c C-M-m") #'my-hydra/term-mode/body)
  (define-key term-raw-map (kbd "C-c C-M-m") #'my-hydra/term-mode/body))
#+end_src

** vterm                                                              :melpa:

[[https://github.com/akermu/emacs-libvterm][emacs-libvterm]] (vterm) is full terminal emulator run inside Emacs
using [[https://launchpad.net/libvterm][libvterm]].

Note this requires Emacs be compiled with modules support enabled
(using the ~--with-modules~ option). If so, ~module-fix-suffix~ will
be non-nil.

The default behavior of emacs-libvterm is to compile libvterm from
source on the first run.

The following instructions show steps needed on macOS to set up the
compile dependencies using MacPorts.

#+begin_example
$ sudo port install cmake libtool
#+end_example

*Configuration*:
- Use shell title to populate buffer name.
- Clearing the screen also clears scrollback history.
- Limit the automatically eval'ed vterm commands in shell output to
  further limit attack vectors for arbitrary code execution.
- Kill vterm buffer automatically on exit.

#+name: vterm
#+begin_src emacs-lisp
(when (and module-file-suffix
           (executable-find "cmake")
           (executable-find "libtool"))
  (use-package vterm
    :init
    (setq vterm-buffer-name-string "vterm %s"
          vterm-clear-scrollback-when-clearing t
          vterm-eval-cmds '(("vterm-clear-scrollback" vterm-clear-scrollback))
          vterm-kill-buffer-on-exit t
          vterm-shell (or (executable-find "fish") shell-file-name))))
#+end_src

*Updating compiled modules*: ~M-x vterm-module-compile~ recompiles
vterm-module, so run it to update to newer versions of libvterm.

*** Shell-side configuration required for specific vterm features

If desired, vterm also has a number of Emacs and shell integration
features (directory tracking, prompt tracking, message parsing, etc)
that require some [[https://github.com/akermu/emacs-libvterm#shell-side-configuration][shell-side configuration]].

Most of these shell-side configurations require a ~vterm_printf~
helper function. For fish, put the following in a
=~/.config/fish/functions/vterm_printf= file.

#+begin_example
# Helper function for sending info from shell to vterm using escape sequences.
# https://github.com/akermu/emacs-libvterm#shell-side-configuration
if [ "$INSIDE_EMACS" = "vterm" ]
    function vterm_printf
        if [ -n "$TMUX" ]
            # tell tmux to pass the escape sequences through
            # (Source: http://permalink.gmane.org/gmane.comp.terminal-emulators.tmux.user/1324)
            printf "\ePtmux;\e\e]%s\007\e\\" "$argv"
        else if string match -q -- "screen*" "$TERM"
            # GNU screen (screen, screen-256color, screen-256color-bce)
            printf "\eP\e]%s\007\e\\" "$argv"
        else
            printf "\e]%s\e\\" "$argv"
        end
    end
end
#+end_example

**** Directory and prompt tracking

Enables using ~C-c C-n~ and ~C-c C-p~ to go the next and previous
prompts respectively while in vterm.

Also allows ~vterm-beginning-of-line~ and ~vterm-at-prompt-p~
functions to better detect prompts.

For fish, create a =~/.config/fish/functions/vterm_prompt_end.fish=
file with the following.

#+begin_example
# Helper function for redefining prompt in config.fish to enable directory
# and prompt tracking in emacs-libvterm
# https://github.com/akermu/emacs-libvterm#directory-tracking-and-prompt-tracking
if [ "$INSIDE_EMACS" = "vterm" ]
    function vterm_prompt_end
        vterm_printf '51;A'(whoami)'@'(hostname)':'(pwd)
    end
end
#+end_example

Next, add the following near the end of the
=~/.config/fish/config.fish= file.

#+begin_example
# Redefine the prompt for directory and prompt tracking in emacs-libvterm
# https://github.com/akermu/emacs-libvterm#directory-tracking-and-prompt-tracking
if [ "$INSIDE_EMACS" = "vterm" ]
    functions -c fish_prompt vterm_old_fish_prompt
    function fish_prompt --description 'Write out the prompt; do not replace this. Instead, put this at end of your file.'
        # Remove the trailing newline from the original prompt. This is done
        # using the string builtin from fish, but to make sure any escape codes
        # are correctly interpreted, use %b for printf.
        printf "%b" (string join "\n" (vterm_old_fish_prompt))
        vterm_prompt_end
    end
end
#+end_example

**** vterm-clear-scrollback-when-clearing support

Required for ~vterm-clear-scrollback-when-clearing~ to work properly
when it is set to non-nil. This automatically clears the scrollback as well
on ~vterm-clear~, which bound to ~C-l~ by default.

Create a =~/.config/fish/functions/clear.fish= file with the following
contents.

#+begin_example
# Redefine clear function to also clear scrollback history in emacs-libvterm
# https://github.com/akermu/emacs-libvterm#vterm-clear-scrollback
if [ "$INSIDE_EMACS" = "vterm" ]
    function clear
        vterm_printf "51;Evterm-clear-scrollback"
        tput clear
    end
end
#+end_example

*** vterm-specific switch-to-buffer

Define a ~switch-to-buffer~ variant restricted to vterm buffers and
the most recently selected buffer besides the current one (this is the
buffer return by ~other-buffer~, and allows for toggling between the
code and vterm), and bind it to ~C-c C-b~ when in ~vterm-mode~.

#+name: vterm-switchb
#+begin_src emacs-lisp
(defun vterm-switchb ()
  "Call `switch-to-buffer' but only for vterm buffers."
  (interactive)
  (let ((completion-regexp-list '("\\`vterm .*")))
    (call-interactively #'switch-to-buffer)))

(with-eval-after-load 'vterm
  (define-key vterm-mode-map (kbd "C-c C-b") #'vterm-switchb))
#+end_src

* Comparison tools

** Ediff

*** Ediff hydra                                                       :hydra:

Hydra for Ediff.

#+name: ediff-hydra
#+begin_src emacs-lisp
;; hydra for Ediff
(defhydra my-hydra/ediff (:color teal :hint nil)
  "
Ediff (_q_: quit)
Buffer   _b_ : 2-way       _B_ : 3-way
Files    _f_ : 2-way       _F_ : 3-way       _c_ : current
Region   _l_ : line-wise   _w_ : word-wise
Windows  _L_ : line-wise   _W_ : word-wise
"
  ("q" nil nil :exit t)
  ("b" ediff-buffers)
  ("B" ediff-buffers3)
  ("f" ediff-files)
  ("F" ediff-files3)
  ("c" ediff-current-file)
  ("l" ediff-regions-linewise)
  ("w" ediff-regions-wordwise)
  ("L" ediff-windows-linewise)
  ("W" ediff-windows-wordwise))

;; binding for Ediff hydra
(global-set-key (kbd "C-c C-M-=") #'my-hydra/ediff/body)
#+end_src

** Smerge

[[https://github.com/emacs-mirror/emacs/blob/master/lisp/vc/smerge-mode.el][Smerge]] is a lightweight alternative to Ediff, and is the default merge
tool called by [[Magit][Magit]] to resolve merge conflicts.

*** Smerge hydra                                                      :hydra:

Major mode-specific hydra for Smerge.
Adapted from [[https://github.com/alphapapa/unpackaged.el#hydra][here]].

#+name: smerge-hydra
#+begin_src emacs-lisp
;; hydra for smerge-mode
(defhydra my-hydra/smerge-mode (:color pink :hint nil)
  "
Smerge (_q_: quit)
Move   _n_   : next          _p_   : prev
Keep   _b_   : base          _u_   : upper         _l_   : lower
       _a_   : all           _RET_ : current
Diff   _<_   : upper/base    _=_   : upper/lower   _>_   : base/lower
       _R_   : refine        _E_   : ediff
Other  _C_   : combine       _r_   : resolve       _k_   : kill current
"
  ("q" nil nil :exit t)
  ("n" smerge-next)
  ("p" smerge-prev)
  ("b" smerge-keep-base)
  ("u" smerge-keep-upper)
  ("l" smerge-keep-lower)
  ("a" smerge-keep-all)
  ("RET" smerge-keep-current)
  ("<" smerge-diff-base-upper)
  ("=" smerge-diff-upper-lower)
  (">" smerge-diff-base-lower)
  ("R" smerge-refine)
  ("E" smerge-ediff)
  ("C" smerge-combine-with-next)
  ("r" smerge-resolve)
  ("k" smerge-kill-current)
  ;; emulate Vim's "ZZ" command to save and close current file
  ("ZZ" (lambda ()
          (interactive)
          (save-buffer)
          (bury-buffer))
   "Save and bury buffer" :exit t))
;; binding
(with-eval-after-load 'smerge-mode
  (define-key smerge-mode-map (kbd "C-c C-M-m") #'my-hydra/smerge-mode/body))
#+end_src

** View and compare directory trees using Ztree

*** Ztree directory tree hydra                                        :hydra:

Major mode-specific hydra for ~ztreedir-mode~.

#+name: ztree-dir-hydra
#+begin_src emacs-lisp
;; mode-specific hydra for ztreedir-mode
(defhydra my-hydra/ztreedir-mode (:color pink :columns 3)
  "
ztree-dir (_q_: quit)"
  ("q" nil nil)
  ("RET" ztree-perform-action "toggle/open-other" :exit t)
  ("SPC" ztree-perform-soft-action "toggle/open" :exit t)
  ("x" ztree-toggle-expand-subtree "toggle" :exit t)
  ("g" ztree-refresh-buffer "refresh" :exit t)
  ("DEL" ztree-move-up-in-tree "goto-parent" :exit t)
  ("H" ztree-dir-toggle-show-filtered-files "show-filtered" :exit t)
  (">" ztree-dir-narrow-to-dir "narrow" :exit t)
  ("<" ztree-dir-widen-to-parent "widen" :exit t)
  ("d" ztree-dir-open-dired-at-point "dired" :exit t))
(with-eval-after-load 'ztree-dir
  (define-key ztreedir-mode-map (kbd "C-c C-M-m") #'my-hydra/ztreedir-mode/body))
#+end_src

*** Ztree directory tree comparison hydra                             :hydra:

Major mode-specific hydra for ~ztreediff-mode~.

#+name: ztree-diff-hydra
#+begin_src emacs-lisp
;; mode-specific hydra for ztreediff-mode
(defhydra my-hydra/ztreediff-mode (:color pink :columns 3)
  "
ztree-diff (_q_: quit)"
  ("q" nil nil)
  ("RET" ztree-perform-action "toggle/ediff" :exit t)
  ("SPC" ztree-perform-soft-action "toggle/diff" :exit t)
  ("TAB" ztree-jump-side "jump-side" :exit t)
  ("x" ztree-toggle-expand-subtree "toggle" :exit t)
  ("g" ztree-refresh-buffer "refresh" :exit t)
  ("DEL" ztree-move-up-in-tree "goto-parent" :exit t)
  ("h" ztree-diff-toggle-show-equal-files "show-equal" :exit t)
  ("H" ztree-diff-toggle-show-filtered-files "show-filtered" :exit t)
  ("d" ztree-diff-simple-diff-files "diff-files" :exit t)
  ("v" ztree-diff-view-file "view" :exit t)
  ("C" ztree-diff-copy "copy" :exit t)
  ("D" ztree-diff-delete-file "delete" :exit t)
  ("r" ztree-diff-partial-rescan "rescan-part" :exit t)
  ("R" ztree-diff-full-rescan "rescan-full" :exit t))
(with-eval-after-load 'ztree-diff
  (define-key ztreediff-mode-map (kbd "C-c C-M-m") #'my-hydra/ztreediff-mode/body))
#+end_src

* Dired

** Dired hydra                                                        :hydra:

Hydra for Dired, one of the heads uses [[dired-filter extension to add Ibuffer-like filters to Dired][dired-filter]].

#+name: dired-hydra
#+begin_src emacs-lisp
;; hydras for Dired
(defhydra my-hydra/dired-mode (:color pink :columns 4)
  "
Dired (_q_: quit)"
  ("q" nil nil :exit t)
  ("RET" (progn
           (dired-find-file)
           (when (eq major-mode 'dired-mode)
             (my-hydra/dired-mode/body)))
   "open" :exit t)
  ("{" find-name-dired "find-name" :exit t)
  ("}" find-grep-dired "find-grep" :exit t)
  ("(" dired-hide-details-mode "toggle-details")
  (")" dired-omit-mode "toggle-omit")
  ("+" dired-create-directory "mkdir")
  ("=" dired-diff "diff" :exit t)
  ("_" dired-show-file-type "show-file-type")
  ("?" dired-summary "help")
  ("A" dired-do-find-regexp "find-regex" :exit t)
  ("C" dired-do-copy "copy")
  ("c" dired-do-compress-to "compress-to")
  ("D" dired-do-delete "delete")
  ("E" dired-mark-extension "mark-ext")
  ("F" dired-do-find-marked-files "find-marked" :exit t)
  ("G" dired-do-chgrp "chgrp")
  ("g" revert-buffer "refresh")
  ("i" dired-maybe-insert-subdir "insert-subdir")
  ("K" my-dired-kill-and-next-subdir "kill-subdir")
  ("l" dired-do-redisplay "redisplay")
  ("M" dired-do-chmod "chmod")
  ("m" dired-mark "mark")
  ("O" dired-display-file "display")
  ("o" dired-find-file-other-window "find-file-o" :exit t)
  ("Q" dired-do-find-regexp-and-replace "find-regex-sub" :exit t)
  ("R" dired-do-rename "rename")
  ("S" dired-do-symlink "symlink")
  ("s" dired-sort-toggle-or-edit "date-sort")
  ("T" dired-do-touch "touch")
  ("t" dired-toggle-marks "toggle-marks")
  ("U" dired-unmark-all-marks "unmark-all")
  ("u" dired-unmark "unmark")
  ("v" dired-view-file "view-file" :exit t) ;; open file in view-mode
  ("Y" dired-do-relsymlink "symlink-to-dir")
  ("Z" dired-do-compress "compress"))
;; binding for dired hydra
(with-eval-after-load 'dired
  (define-key dired-mode-map (kbd "C-c C-M-m") #'my-hydra/dired-mode/body))
#+end_src

*** Helper functions for Dired hydra

Helper functions for Dired hydra:
- Kill a Dired directory buffer and jump to its parent.

#+name: dired-hydra-helper-functions
#+begin_src emacs-lisp
;; adapted from https://www.reddit.com/r/emacs/comments/jh1me/keeping_large_dired_buffers_tidy/
(defun my-dired-kill-and-next-subdir ()
  "Kill current subdir in dired, and jump back to its parent dir."
  (interactive)
  (let* ((subdir-name (directory-file-name (dired-current-directory)))
         (parent-dir  (file-name-directory subdir-name))
         (search-term (concat " "
                              (file-name-base subdir-name)
                              (file-name-extension subdir-name t))))
    (dired-kill-subdir)
    (dired-goto-subdir parent-dir)
    (search-forward search-term)))
#+end_src

** Dired icons using treemacs-icons-dired                             :melpa:

Add icons from [[https://github.com/Alexander-Miller/treemacs][Treemacs]] to Dired.

Requires the ~treemacs~ package be installed.

#+name: treemacs-icons-dired
#+begin_src emacs-lisp
;; use Treemacs icons in Dired
(when (display-graphic-p)
  (use-package treemacs-icons-dired
    :after dired
    :hook (dired-mode . treemacs-icons-dired-mode)))
#+end_src

** dired-filter extension to add Ibuffer-like filters to Dired

*** dired-filter hydra                                                :hydra:

Hydra for ~dired-filter~.
Entrypoint is through the [[Dired hydra]].

#+name: dired-filter-hydra
#+begin_src emacs-lisp
;; add dired-filter hydra
(defhydra my-hydra/dired-mode/filter (:color pink :columns 4)
  "
Dired → Filter (_q_: ←)"
  ("q" my-hydra/dired-mode/body nil :exit t)
  ("n" dired-filter-by-name "by-name")
  ("r" dired-filter-by-regex "by-regex")
  ("." dired-filter-by-extension "by-ext")
  ("h" dired-filter-by-dot-files "by-hidden")
  ("o" dired-filter-by-omit "by-omit")
  ("g" dired-filter-by-garbage "by-garbage")
  ("e" dired-filter-by-predicate "by-pred")
  ("f" dired-filter-by-file "by-file")
  ("d" dired-filter-by-directory "by-dir")
  ("m" dired-filter-by-mode "by-mode")
  ("s" dired-filter-by-symlink "by-symlink")
  ("x" dired-filter-by-executable "by-exe")
  ("ig" dired-filter-by-git-ignored "by-git-ign")
  ("|" dired-filter-or "or")
  ("!" dired-filter-negate "negate")
  ("*" dired-filter-decompose "decompose")
  ("TAB" dired-filter-transpose "transpose")
  ("p" dired-filter-pop "pop")
  ("/" dired-filter-pop-all "reset")
  ("S" dired-filter-save-filters "save")
  ("D" dired-filter-delete-saved-filters "del")
  ("A" dired-filter-add-saved-filters "add")
  ("L" dired-filter-load-saved-filters "load"))
;; add entrypoint for dired-filter hydra in my-hydra/dired-mode
(defhydra+ my-hydra/dired-mode nil
  ("/" my-hydra/dired-mode/filter/body "→ Filter" :exit t))
#+end_src

** Have recentf also track dired buffers

Have recentf track dired buffers as well. From [[https://www.emacswiki.org/emacs/RecentFiles#toc21][here]].

Alternative is [[https://github.com/Vifon/dired-recent.el][dired-recent]].

#+name: recentf-track-dired-buffers
#+begin_src emacs-lisp
;; have recentf track dired buffers as well
;; from https://www.emacswiki.org/emacs/RecentFiles#toc21

(defun recentd-track-opened-file ()
  "Insert the name of the directory just opened into the recent list."
  (and (derived-mode-p 'dired-mode) default-directory
       (recentf-add-file default-directory))
  ;; Must return nil because it is run from `write-file-functions'.
  nil)

(defun recentd-track-closed-file ()
  "Update the recent list when a dired buffer is killed.
That is, remove a non kept dired from the recent list."
  (and (derived-mode-p 'dired-mode) default-directory
       (recentf-remove-if-non-kept default-directory)))

(add-hook 'dired-after-readin-hook 'recentd-track-opened-file)
(add-hook 'kill-buffer-hook 'recentd-track-closed-file)
#+end_src

** Dired icons using all-the-icons-dired                   :workaround:melpa:

Add font icons from ~all-the-icons~ to Dired using [[https://github.com/jtbm37/all-the-icons-dired][all-the-icons-dired]].
Requires the ~all-the-icons~ package be loaded.

#+name: all-the-icons-dired
#+begin_src emacs-lisp
;; use font icons in Dired
(use-package all-the-icons-dired
  :after (all-the-icons dired)
  :hook (dired-mode . all-the-icons-dired-mode)
  :config
  (set-face-attribute 'all-the-icons-dired-dir-face nil
                      :weight 'normal)
  ;; extra workaround to avoid misalignment in filenames due to with
  ;; varying icon widths
  ;; https://github.com/jtbm37/all-the-icons-dired/issues/10
  (advice-add 'all-the-icons-dired--setup :after
              (lambda () (setq-local tab-width 2))))
#+end_src

* Editing text

** Keyboard macros hydra                                              :hydra:

Hydra for manipulating and using Emacs [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Keyboard-Macros.html][keyboard macros]].
For an example, see the writeup on [[https://www.emacswiki.org/emacs/KeyboardMacros][EmacsWiki]].

#+name: kmacros-hydra
#+begin_src emacs-lisp
(defhydra my-hydra/kmacros (:color teal :columns 3)
  "
Keyboard Macros (_q_: quit)"
  ("q" nil nil)
  ;; start, end and execute macros
  ("(" kmacro-start-macro "start")
  (")" kmacro-end-or-call-macro "end-or-call-last")
  ("r" apply-macro-to-region-lines "call-last-region")
  ;; macro ring
  ("C-n" kmacro-cycle-ring-next "cycle-ring-next" :exit nil)
  ("C-p" kmacro-cycle-ring-previous "cycle-ring-prev" :exit nil)
  ("C-v" kmacro-view-macro "view-last" :exit nil)
  ("C-d" kmacro-delete-ring-head "delete-ring-head" :exit nil)
  ;; macro editing
  ("e" edit-kbd-macro "edit")
  ("RET" kmacro-edit-macro "edit-last")
  ("l" kmacro-edit-lossage "edit-lossage")
  ("SPC" kmacro-step-edit-macro "step-edit")
  ;; naming and binding
  ("b" kmacro-bind-to-key "bind-to-key")
  ("n" kmacro-name-last-macro "name-last")
  ("x" kmacro-to-register "to-register")
  ;; other
  ("i" insert-kbd-macro "insert-named"))
(global-set-key (kbd "C-c C-M-k") 'my-hydra/kmacros/body)
#+end_src

** Snippet expansion using YASnippet

*** YASnippet hydra                                                   :hydra:

Hydra for ~yas-minor-mode~ YASnippet commands and YASnippet supporting
packages.

#+name: yasnippet-hydra
#+begin_src emacs-lisp
;; hydra for YASnippet commands
(defhydra my-hydra/yas-minor-mode (:color teal :columns 4)
  "
YASnippet (_q_: quit)"
  ("q" nil nil)
  ("SPC" yas-expand "expand") ;; expand snippet
  ("d" yas-describe-tables "describe") ;; snippets for current mode
  ("s" yas-insert-snippet "insert") ;; insert snippet
  ("n" yas-new-snippet "new") ;; create new snippet
  ("v" yas-visit-snippet-file "visit-snippet") ;; visit snippet file
  ("w" aya-create "create-auto") ;; store temp snippet
  ("y" aya-expand "expand-auto") ;; paste temp snippet
  ("?" (message "Current auto-yasnippet:\n%s" aya-current)
   "current-auto")) ;; show temp snippet
(with-eval-after-load 'yasnippet
  (define-key yas-minor-mode-map (kbd "C-c C-M-<") #'my-hydra/yas-minor-mode/body))
#+end_src

** Multiple cursors

*** Multiple cursors hydra                                            :hydra:

Hydra providing usage hints for ~multiple-cursor-mode~.
It enables ~multiple-cursors-mode~ automatically on entrance and
disables ~multiple-cursors-mode~ on exit.

#+name: multiple-cursors-hydra
#+begin_src emacs-lisp
;; hydra helper for multiple-cursors-mode
;; disable prefix interpretation when multiple-cursors-mode is active
;; see https://stackoverflow.com/questions/53798055
(defhydra my-hydra/multiple-cursors (:color pink :hint nil
                                     :base-map (make-sparse-keymap))
  "
Multiple-cursors (_C-g_: quit)
Mark    _C-<_: add-prev _C->_: add-next _C-%_: add-all  _C-s_: search
        _C-,_: skp-prev _C-._: skp-next _M-<_: rm-prev  _M->_: rm-next
        _C-|_: edit-lns _<mouse-1>_: add/remove
Misc    _C-{_: number   _C-}_: letter
"
  ("C-g" (lambda ()
           (interactive)
           (mc/keyboard-quit)
           (when multiple-cursors-mode
             (my-hydra/multiple-cursors/body))) :exit t)
  ("C-<" mc/mark-previous-like-this)
  ("C-," mc/skip-to-previous-like-this)
  ("M-<" mc/unmark-previous-like-this)
  ("C->" mc/mark-next-like-this)
  ("C-." mc/skip-to-next-like-this)
  ("M->" mc/unmark-next-like-this)
  ("C-%" mc/mark-all-like-this)
  ("C-s" mc/mark-all-in-region-regexp)
  ("<mouse-1>" mc/add-cursor-on-click)
  ("<down-mouse-1>" ignore)
  ("<drag-mouse-1>" ignore)
  ("<wheel-up>" scroll-down-line)
  ("<wheel-down" scroll-up-line)
  ("C-{" mc/insert-numbers)
  ("C-}" mc/insert-letters)
  ("C-|" mc/edit-lines))

;; bind multiple-cursors hydra
(global-set-key (kbd "C-c C-M-c") #'my-hydra/multiple-cursors/body)
#+end_src

** Registers hydra                                                    :hydra:

Hydra for easier [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Registers.html][register]] manipulation and usage.

#+name: registers-hydra
#+begin_src emacs-lisp
(defhydra my-hydra/registers (:color teal :columns 4)
  "
Registers (_q_: quit)"
  ("q" nil nil)
  ("SPC" point-to-register "save-point")
  ("w" window-configuration-to-register "save-windows")
  ("f" frameset-to-register "save-frames")
  ("j" jump-to-register "jump")
  ("s" copy-to-register "copy-region")
  ("a" append-to-register "append-region")
  ("p" prepend-to-register "prepend-region")
  ("r" copy-rectangle-to-register "copy-rect")
  ("i" insert-register "insert")
  ("l" list-registers "list")
  ("v" view-register "view"))
(global-set-key (kbd "C-c C-M-\"") 'my-hydra/registers/body)
#+end_src

** beginend for dwim behavior for "M-<" and "M->"                     :melpa:

[[https://github.com/DamienCassou/beginend][Beginend]] redefines ~beginning-of-buffer~ and ~end-of-buffer~ (~M-<~
and ~M->~ by default) to move the point to locations that make sense
for supported major modes. Go to the real beginning and end of buffer
by pressing the same key sequence again.

#+name: beginend
#+begin_src emacs-lisp
;; dwim behavior for `beginning-of-buffer' and `end-of-buffer'
(use-package beginend
  :config
  ;; enable beginend-mode is all supported major modes
  (beginend-global-mode))
#+end_src

** Symbol overlays and operations                                     :melpa:

[[https://github.com/wolray/symbol-overlay][symbol-overlay]] provides the ability to highlight symbols with overlays
and a keymap for different operations on the highlighted symbols.

#+name: symbol-overlay
#+begin_src emacs-lisp
(use-package symbol-overlay
  :demand t
  :init
  ;; don't use `symbol-overlay-map' as it conflicts with `iedit-mode',
  ;; a transient is be defined later to access symbol-overlay commands
  (setq symbol-overlay-inhibit-map t)
  :config
  ;; advise symbol-overlay jump functions to perform context actions
  ;; after they are run
  (dolist (jump-fun '(symbol-overlay-jump-next
                      symbol-overlay-jump-prev
                      symbol-overlay-switch-forward
                      symbol-overlay-switch-backward))
    (advice-add jump-fun :after #'my-after-jump-context-actions)))
#+end_src

* Emacs as an edit server

** Emacs client-server hydra                                          :hydra:

Hydra for Emacs client-server interaction.

#+name: emacs-client-server-hydra
#+begin_src emacs-lisp
;; hydra for Emacs server interaction
(defhydra my-hydra/emacs-client-server (:color teal :hint nil
                                        :pre (require 'server))
  "
Emacs client-server interaction (_q_: quit)
Server  [% 3`server-mode]   _s_ : toggle  _r_ : restart"
  ("q" nil)
  ("s" server-mode :exit nil)
  ("r" restart-emacs-server))

;; binding for Emacs server hydra
(global-set-key (kbd "C-c C-M-S-s") #'my-hydra/emacs-client-server/body)
#+end_src

* Email

** OrgMsg for composing HTML emails

*** Modifying the org-msg setup function to not remove quoted text

Redefine ~org-msg-post-setup~ ([[https://github.com/jeremy-compostella/org-msg/blob/master/org-msg.el#L872-L908][link to source]]) so that quoted text is
not removed when replying to emails, much like Gmail and other modern
mail programs.

#+name: org-msg-post-setup-no-remove-quote-text
#+begin_src emacs-lisp
;; redefine `org-msg-post-setup' so quoted text is not removed when
;; replying to emails like in Gmail and other modern mail programs
;; https://github.com/jeremy-compostella/org-msg/blob/master/org-msg.el#L872-L908
(with-eval-after-load 'org-msg
  (defun org-msg-post-setup (&rest _args)
    "Transform the current `message' buffer into a OrgMsg buffer.
If the current `message' buffer is a reply, the
`org-msg-separator' string is inserted at the end of the editing
area."
    (unless (eq major-mode 'org-msg-edit-mode)
      (message-goto-body)
      (let ((new (not (org-msg-message-fetch-field "subject")))
            (with-original (not (= (point) (point-max))))
            (reply-to))
        (when (or new (org-msg-mua-call 'article-htmlp))
          (unless new
            (setq reply-to (org-msg-mua-call 'save-article-for-reply)))
          (insert (org-msg-header reply-to))
          (when org-msg-greeting-fmt
            (insert (format org-msg-greeting-fmt
                            (if new
                                ""
                              (org-msg-get-to-first-name)))))
          (save-excursion
            (insert "\n\n")
            (when with-original
              (org-escape-code-in-region (point) (point-max)))
            (save-excursion
              (end-of-buffer)
              (when org-msg-signature
                (insert org-msg-signature)))
            (org-msg-edit-mode))
          (set-buffer-modified-p nil))
        (if (org-msg-message-fetch-field "to")
            (recenter)
          (message-goto-to))))))
#+end_src

*** Use Gmail blockquotes for quoted text in OrgMsg replies

Try to replicate Gmail-style blockquotes for quoted text.

#+name: org-msg-use-gmail-blockquotes
#+begin_src emacs-lisp
;; set up Gmail-style citations in replies
(with-eval-after-load 'notmuch
  (with-eval-after-load 'org-msg
    ;; configure message-mode citation settings to be more Gmail-like
    ;; https://emacs.stackexchange.com/questions/14625/how-to-control-quoting-of-original-message-when-replying
    (setq notmuch-mua-cite-function 'message-cite-original
          message-fill-column nil ;; don't break paragraphs
          message-citation-line-function 'message-insert-formatted-citation-line
          message-cite-reply-position 'above
          ;; message-yank-prefix "    "
          ;; message-yank-cited-prefix "    "
          ;; message-yank-empty-prefix "    "
          message-citation-line-format "On %a, %b %e, %Y at %l:%M %p %f wrote:
")
    ;; modify HTML text to use Gmail blockquotes in place of '>'
    (defun my-gmail-quote-html (htmltext)
      "Modify HTMLTEXT to use Gmail blockquotes."
      (let ((blockquote-begin
             (concat "<blockquote type=\"gmail_quote\" "
                     "style=\"margin:0px 0px 0px 0.8ex;"
                     "border-left:1px solid rgb(204,204,204);"
                     "padding-left:1ex\""
                     ">\n"))
            (blockquote-end "</blockquote>\n"))
        (with-temp-buffer
          ;; change message citation line HTML from a <p> element to a
          ;; <div> element with class 'gmail_quote'
          (insert (replace-regexp-in-string
                   (concat "<p[^\n\r]*>[\n\r]"
                           "\\([^\r\n]*\\)"
                           "</p>"
                           "\\([\n\r]*<p[^\n\r]*>[\n\r]*&gt;\\)")
                   "<br/><div class=\"gmail_quote\">\\1</div>\\2"
                   htmltext))
          ;; process one line at a time to traverse blockquote levels
          ;; using the number of leading '>' characters in each line
          (goto-char (point-min))
          (let ((blockquote-level 0))
            (while (not (eobp))
              (let ((line-level 0))
                (while (looking-at "&gt;[[:blank:]]*")
                  (replace-match "")
                  (cl-incf line-level))
                (while (< blockquote-level line-level)
                  (insert blockquote-begin)
                  (cl-incf blockquote-level))
                (while (> blockquote-level line-level)
                  (insert blockquote-end)
                  (cl-decf blockquote-level)))
              (forward-line)))
          (buffer-string))))
    (defun org-msg-preview (arg)
      "Create a temporary mail and open it with `browse-url'.
With the prefix argument ARG set, it calls
`xwidget-webkit-browse-url' instead of `browse-url'.
Modified copy of original using Gmail blockquotes."
      (interactive "P")
      (save-window-excursion
        (let ((browse-url-browser-function (if arg
                                               'xwidget-webkit-browse-url
                                             browse-url-browser-function))
              (tmp-file (make-temp-file "org-msg" nil ".html"))
              (mail (org-msg-build)))
          (with-temp-buffer
            ;; following line modified from original
            (insert (my-gmail-quote-html (org-msg-xml-to-str mail)))
            (write-file tmp-file))
          (browse-url (concat "file://" tmp-file)))))
    (defun org-msg-prepare-to-send ()
      "Convert the current OrgMsg buffer into `mml' content.
This function is a hook for `message-send-hook'.
Modified copy of original using Gmail blockquotes."
      (save-window-excursion
        (when (eq major-mode 'org-msg-edit-mode)
          (let ((mail (org-msg-build))
                (attachments (org-msg-get-prop "attachment")))
            (dolist (file attachments)
              (unless (file-exists-p file)
                (error "File '%s' does not exist" file)))
            (setq org-msg-attachment attachments)
            (when org-msg-text-plain-alternative
              (setq org-msg-text-plain (org-msg-org-to-text-plain)))
            (goto-char (org-msg-start))
            (delete-region (org-msg-start) (point-max))
            (when (org-msg-mml-recursive-support)
              (when attachments
                (mml-insert-multipart "mixed")
                (dolist (file attachments)
                  (mml-insert-tag 'part 'type (org-msg-file-mime-type file)
                                  'filename file 'disposition "attachment")))
              (when org-msg-text-plain-alternative
                (mml-insert-multipart "alternative")
                (mml-insert-part "text/plain")
                (insert org-msg-text-plain)
                (forward-line)))
            (mml-insert-part "text/html")
            ;; following line modified from original
            (insert (my-gmail-quote-html (org-msg-xml-to-str mail)))))))))
#+end_src

*** OrgMsg hydra                                                      :hydra:

Major mode-specific hydra for ~org-msg-edit-mode~ for jumping to
various parts of the email and performing email-related actions.

*Note*: ~org-msg-edit-mode~ is in effect when editing email messages
with ~org-msg-mode~ enabled.

#+name: org-msg-edit-mode-hydra
#+begin_src emacs-lisp
;; major mode-specific hydra for OrgMsg edit mode
(with-eval-after-load 'org-msg
  (defhydra my-hydra/org-msg-edit-mode (:color teal :columns 6)
    "
OrgMsg (_q_: quit)"
    ("q" nil nil)
    ("f" message-goto-from "from")
    ("t" message-goto-to "to")
    ("c" message-goto-cc "cc")
    ("B" message-goto-bcc "bcc")
    ("F" message-goto-fcc "fcc")
    ("S" message-goto-subject "subj")
    ("b" org-msg-goto-body "body")
    ("C-a" org-msg-attach "attach")
    ("C-e" org-msg-preview "preview")
    ("C-c" org-ctrl-c-ctrl-c "send")
    ("C-k" org-msg-edit-kill-buffer "kill"))

  ;; binding for org-msg-edit-mode
  (define-key org-msg-edit-mode-map (kbd "C-c C-M-m")
    #'my-hydra/org-msg-edit-mode/body))
#+end_src

* Information

** Display current time in minibuffer

Convenience function for displaying the current time in minibuffer.

#+name: display-current-datetime
#+begin_src emacs-lisp
(defun my-display-current-datetime ()
  "Display the current time in the minibuffer."
  (interactive)
  (message (format-time-string "%Y-%b-%d %l:%M:%S%p %Z %A")))
#+end_src

** Emacs information

Convenience functions for displaying Emacs process and build info.

#+name: display-emacs-info
#+begin_src emacs-lisp
(defun my-display-emacs-pid ()
  "Display the process id of current Emacs process in the minibuffer."
  (interactive)
  (message (format "%d" (emacs-pid))))

(defun my-display-emacs-build-configuration ()
  "Display the Emacs build configuration in the minibuffer."
  (interactive)
  (message (mapconcat 'identity
                      `("Emacs build configuration"
                        ,(format "  Build target:     %s"
                                 system-configuration)
                        ,(format "  Enabled features: %s"
                                 system-configuration-features))
                      "\n")))
#+end_src

** System process management with proced

[[https://github.com/emacs-mirror/emacs/blob/master/lisp/proced.el][Proced]] lists system processes in a buffer and provides
commands to operate to listed processes.
It can be used like [[https://en.wikipedia.org/wiki/Top_(software)][top]] by toggling auto-refresh
using ~M-x proced-toggle-auto-update~.

Note that macOS isn't very well supported by this package,
so configure it only for Linux systems.
For macOS, an alternative is using ~top~ in an ~term-mode~ buffer.

For more usage information, see [[https://www.masteringemacs.org/article/displaying-interacting-processes-proced][here]].

#+name: proced
#+begin_src emacs-lisp
;; manage system processes in Linux
(when (eq system-type 'gnu/linux)
  (setq proced-format 'medium))
#+end_src

** Information hydra

Hydra for random information, like the current datetime or system
resource usage.

#+name: info-hydra
#+begin_src emacs-lisp
(defhydra my-hydra/info (:color amaranth :columns 3)
  "
Info (_q_: quit)"
  ("q" nil nil :exit t)
  ("b" my-display-emacs-build-configuration "emacs-build-config")
  ("i" emacs-init-time "emacs-init-time")
  ("P" my-display-emacs-pid "emacs-pid")
  ("p" proced "proced" :exit t)
  ("t" my-display-current-datetime "datetime")
  ("T" display-time-world "world-time" :exit t)
  ("u" emacs-uptime "emacs-uptime")
  ("v" emacs-version "version"))

(global-set-key (kbd "C-c C-M-i") #'my-hydra/info/body)
#+end_src

* Marks and markers

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Mark.html][Marks]] and [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Markers.html][markers]] are useful for saving point locations and jumping
back to them later.

They can be thought of as temporary bookmarks, and can be
set up so that they are automatically created.

Examples of automatic mark and marker creation configured by default:
- Isearch automatically creates marks where the search originated.
- Calling ~xref-find-definitions~ automatically creates a marker where
  the jump was initiated.

** Marks and markers hydra

Hydra for manipulating and managing marks and markers.

#+name: marks-and-markers-hydra
#+begin_src emacs-lisp
;; backtrack through the entire xref--marker-ring in a single action
(defun xref-pop-marker-stack-all ()
  "Pop back to where `xref-find-definitions' was first invoked.
\\[xref-find-definitions] is the current binding for `xref-find-definitions'."
  (interactive)
  (let ((ring xref--marker-ring))
    (when (ring-empty-p ring)
      (user-error "Marker stack is empty"))
    (let ((marker (ring-remove ring nil))) ;; oldest marker
      (switch-to-buffer (or (marker-buffer marker)
                            (user-error "The marked buffer has been deleted")))
      (goto-char (marker-position marker))
      (set-marker marker nil nil)
      (run-hooks 'xref-after-return-hook)
      (xref-clear-marker-stack)))) ;; clear the rest of the marker stack

;; hydra for manipulating and managing marks and markers
(defhydra my-hydra/marks-and-markers (:color amaranth :columns 3)
  "
Marks / Markers (_q_: quit)"
  ("q" nil nil :exit t)
  ("SPC" (lambda ()
           (interactive)
           (push-mark))
   "mark-push" :exit t)
  ("S-SPC" (lambda ()
             (interactive)
             (set-mark-command t))
   "mark-pop")
  (")" mark-sexp "mark-sexp")
  ("}" mark-paragraph "mark-paragraph")
  ("]" mark-defun "mark-defun")
  ("b" mark-whole-buffer "mark-whole-buf")
  ("x" exchange-point-and-mark "exchange-pt-mk")
  ("." (lambda ()
         (interactive)
         (xref-push-marker-stack))
   "xref-push-marker" :exit t)
  ("," xref-pop-marker-stack "xref-pop-marker")
  ("<" xref-pop-marker-stack-all "xref-pop-markers")
  ("c" (lambda ()
         (interactive)
         (xref-clear-marker-stack)
         (message "Cleared xref--marker-ring"))
   "xref-clear-markers"))
(global-set-key (kbd "C-c C-M-,") 'my-hydra/marks-and-markers/body)
#+end_src

** Add helm mark ring entrypoints to marks hydra                      :hydra:

Add entry point to ~helm-mark-ring~ and ~helm-all-mark-rings~ to
the marks and markers hydra.

#+name: add-helm-mark-ring-to-marks-and-markers-hydra
#+begin_src emacs-lisp
(with-eval-after-load 'helm
  (defhydra+ my-hydra/marks-and-markers nil
    ("m" helm-mark-ring "helm-marks-buf" :exit t)
    ("M" helm-all-mark-rings "helm-marks-all" :exit t)))
#+end_src

* Non-programming files

** csv-mode for comma-delimited and tab-delimited files (CSV, TSV)

*** csv-mode hydra                                                    :hydra:

Hydra for ~csv-mode~.

#+name: csv-mode-hydra
#+begin_src emacs-lisp
;; major mode-specific hydra for csv-mode
(defhydra my-hydra/csv-mode (:color teal :columns 4)
  "
CSV (_q_: quit)"
  ("q" nil nil)
  ("s" csv-sort-fields "sort")
  ("n" csv-sort-numeric-fields "numsort")
  ("r" csv-reverse-region "reverse")
  ("d" csv-toggle-descending "toggle-desc-sort" :exit nil)
  ("t" csv-transpose "transpose")
  ("k" csv-kill-fields "cut")
  ("y" csv-yank-fields "paste")
  ("z" csv-yank-as-new-table "paste-as-new-tab")
  ("A" csv-align-visible-fields "align-visible" :exit nil)
  ("a" csv-align-fields "align" :exit nil)
  ("u" csv-unalign-fields "unalign" :exit nil)
  ("h" csv-header-line "toggle-header" :exit nil)
  ("v" csv-toggle-invisibility "toggle-invis-sep" :exit nil))

;; binding for csv-mode hydra
(with-eval-after-load 'csv-mode
  (define-key csv-mode-map (kbd "C-c C-M-m") #'my-hydra/csv-mode/body))
#+end_src

** markdown-mode for Markdown files

*** markdown-mode hydra                                               :hydra:

Major mode-specific hydra for ~markdown-mode~.

#+name: markdown-mode-hydra
#+begin_src emacs-lisp
;; major mode-specific hydra for markdown-mode
(defhydra my-hydra/markdown-mode (:color teal :hint nil)
  "
Markdown mode (_q_: quit)
Keymaps     _c_ : commands  _s_ : styles
Outline     _n_ : next      _p_ : prev      _f_ : fwd-level _b_ : bwd-level
            _←_ : promote   _→_ : demote    _↓_ : move-down _↑_ : move-up
Shift-Rgn   _<_ : left      _>_ : right
Toggle      _E_ : math      _F_ : code-font _I_ : images    _L_ : url
            _M_ : markup
Other       _d_ : do        _o_ : follow    _'_ : edit code block
"
  ("q" nil nil)
  ;; keymaps
  ("c" (lambda () (interactive) (setq unread-command-events (listify-key-sequence "\C-c\C-c"))))
  ("s" (lambda () (interactive) (setq unread-command-events (listify-key-sequence "\C-c\C-s"))))
  ;; outline
  ("n" markdown-outline-next :color red)
  ("p" markdown-outline-previous :color red)
  ("f" markdown-outline-next-same-level :color red)
  ("b" markdown-outline-previous-same-level :color red)
  ("<left>" markdown-promote :color red)
  ("<right>" markdown-demote :color red)
  ("<down>" markdown-move-down :color red)
  ("<up>" markdown-move-up :color red)
  ;; shift region
  ("<" markdown-outdent-region :color red)
  (">" markdown-indent-region :color red)
  ;; user interface
  ("E" markdown-toggle-math)
  ("F" markdown-toggle-fontify-code-blocks-natively)
  ("I" markdown-toggle-inline-images)
  ("L" markdown-toggle-url-hiding)
  ("M" markdown-toggle-markup-hiding)
  ;; other
  ("d" markdown-do)
  ("o" markdown-follow-thing-at-point)
  ("'" markdown-edit-code-block))

;; bindings for markdown-mode hydra
(with-eval-after-load 'markdown-mode
  (define-key gfm-mode-map (kbd "C-c C-M-m") #'my-hydra/markdown-mode/body)
  (define-key markdown-mode-map (kbd "C-c C-M-m") #'my-hydra/markdown-mode/body))
#+end_src

*** markdown-toc for creating tables of content in Markdown buffers

**** Add heads to create or remove Markdown TOCs to markdown-mode hydra :hydra:

#+name: add-markdown-toc-to-markdown-mode-hydra
#+begin_src emacs-lisp
;; add heads to create, update and delete tables of contents in
;; markdown-mode buffers
(with-eval-after-load 'markdown-toc
  (defhydra+ my-hydra/markdown-mode nil
    ("t" markdown-toc-generate-or-refresh-toc "insert-or-refresh-toc")
    ("C-t" markdown-toc-delete-toc "delete-toc")))
#+end_src

** neuron-mode                                               :external:melpa:

[[https://github.com/felko/neuron-mode][neuron-mode]] is a mode for editing [[https://neuron.zettel.page/][neuron]] zettelkasten notes.

Assumes that neuron Zettelkasten files are stored in the
=~/zettelkasten= directory.

Requires ~neuron~ which is available as a Linux bundle or which can be
installed using [[https://nixos.org/][nixpkg]].

#+name: neuron-mode
#+begin_src emacs-lisp
;; neuron-mode, settings adapted from
;; https://gist.github.com/felko/cdb3fc19b3a60db27eb3c5bd319fc479
(use-package neuron-mode
  :init
  (defface neuron-stub-face
    '((((class color) (min-colors 88) (background dark)) :foreground "#C16069" :underline "#C16069")
      (((class color) (min-colors 88) (background light)) :foreground "#C16069" :underline "#C16069")
      (((class color) :foreground "Red" :underline "Red"))
      (t :inherit neuron-title-overlay-face))
    "Face for stub links."
    :group 'neuron-faces)
  (setq neuron-default-zettelkasten-directory (expand-file-name "~/zettelkasten")
        neuron-default-tags '("stub")
        neuron-id-format 'hash
        neuron-tag-specific-title-faces '(("stub" neuron-stub-face)))
  :config
  ;; push location on to marker stack before following neuron link
  ;; so backtracking is possible via `xref-pop-marker-stack' or "M-,"
  (advice-add #'neuron-follow-thing-at-point :before #'xref-push-marker-stack))
#+end_src

*** Installing neuron

Some ways to install neuron:
- Download a static Linux bundle that can run as is (Linux-only).
- Install using [[https://nixos.org/][Nix]] (Linux, Mac, Windows via WSL).

**** Linux bundle

Nightly builds of static Linux bundles are available from [[https://github.com/srid/neuron/releases/tag/nightly][here]],
generated using [[https://github.com/matthewbauer/nix-bundle][nix-bundle]]. These can simply be run directly.

Download ~neuron-linux-bundle~ to some location on disk, say to the
=/path/to/= directory.

#+begin_example
$ chmod +x neuron-linux-bundle
$ ./neuron-linux-bundle --help
#+end_example

Symlink the bundle file to ~neuron~ a directory in ~$PATH~ (change
=./local/bin= and =/path/to/neuron-linux-bundle= as necessary).

#+begin_example
$ cd .local/bin
$ ln -s /path/to/neuron-linux-bundle neuron
#+end_example

Test that neuron is installed correctly.

#+begin_example
$ neuron --help
#+end_example

**** Nix installation

Install Nix. The following instructions show how to install Nix
in single-user mode; see the [[https://nixos.org/nix/manual/][official documentation]] for a multi-user
install.

#+begin_example
$ sudo mkdir /nix
$ sudo chown $USER /nix
$ curl -O https://nixos.org/nix/install
$ bash install --no-daemon
#+end_example

Note that the Nix =install= script can be safely removed after this.

Install neuron following [[https://neuron.zettel.page/2011501.html][instructions]] on the official website.

Install [[https://cachix.org/][Cachix]] if haven't already done so.

#+begin_example
$ nix-env -iA cachix -f https://cachix.org/api/v1/install
#+end_example

Use the cache to fetch binaries instead of compiling most packages.

#+begin_example
$ cachix use srid
#+end_example

Install Neuron.

#+begin_example
$ nix-env -if https://github.com/srid/neuron/archive/master.tar.gz
#+end_example

*** Upgrading neuron

Neuron upgrades can be done using the same command for installing it.

#+begin_example
$ nix-env -if https://github.com/srid/neuron/archive/master.tar.gz
#+end_example

*** neuron-mode hydras                                                :hydra:

Hydras for interacting with the configured neuron Zettelkasten, and
when editing neuron zettels.

#+name: neuron-hydra
#+begin_src emacs-lisp
;; entrypoint hydra into neuron Zettelkasten
(defhydra my-hydra/neuron (:color teal :columns 4)
  "
Neuron Zettelkasten (_q_: quit)"
  ("q" nil nil)
  ("z" neuron-new-zettel "new")
  ("e" neuron-edit-zettel "edit")
  ("o" neuron-open-zettel "open")
  ("O" neuron-open-index "index")
  ("j" neuron-open-daily-notes "daily")
  ("t" neuron-query-tags "query-tags")
  ("g" neuron-refresh "refresh")
  ("c" neuron-edit-zettelkasten-configuration "config")
  ("rw" neuron-rib-watch "rib-watch")
  ("rg" neuron-rib-generate "rib-gen")
  ("rs" neuron-rib-serve "rib-serve")
  ("ro" neuron-rib-open-zettel "rib-open")
  ("rz" neuron-rib-open-z-index "rib-z-idx")
  ("rk" neuron-rib-kill "rib-kill"))

;; binding for neuron entrypoint hydra
(with-eval-after-load 'neuron-mode
  (global-set-key (kbd "C-c C-M-z") #'my-hydra/neuron/body))
#+end_src

#+name: neuron-mode-hydra
#+begin_src emacs-lisp
;; mode-specific hydra for neuron-mode
(defhydra my-hydra/neuron-mode (:color teal :columns 3)
  "
Neuron mode (_q_: quit)"
  ("q" nil nil)
  ("u" neuron-edit-uplink "edit-uplink")
  ("t" neuron-add-tag "add-tag")
  ("T" neuron-add-tags "add-tags")
  ("l" neuron-create-and-insert-zettel-link "create-link")
  ("L" neuron-create-zettel-from-selected-title "create-selected")
  ("s" neuron-insert-static-link "insert-static-link")
  ("c" neuron-toggle-connection-type "toggle-conn-type")
  ("r" neuron-open-current-zettel "open-current")
  ("o" neuron-follow-thing-at-point "follow"))

;; wrapper hydra for accessing markdown and neuron-mode hydras from
;; mode-specific entrypoint
(defhydra my-hydra/markdown-neuron-mode-wrapper (:color teal)
  "
Markdown mode hydra / Neuron mode hydra (_q_: quit)
"
  ("q" nil nil)
  ("m" my-hydra/markdown-mode/body "markdown-mode")
  ("z" my-hydra/neuron-mode/body "neuron-mode"))

;; binding for mode-specific wrapper hydra for markdown/neuron modes
(with-eval-after-load 'neuron-mode
  (add-hook 'neuron-mode-hook
            (lambda ()
              (use-local-map (copy-keymap markdown-mode-map))
              (local-set-key (kbd "C-c C-M-m")
                             #'my-hydra/markdown-neuron-mode-wrapper/body))))
#+end_src

* Org-mode

** org-bullets for nicer header bullets in Org-mode                   :melpa:

[[https://github.com/integral-dw/org-bullets][org-bullets]] mode replaces header stars in Org-mode with UTF-8
characters that can be customized to differ by header leve.

#+name: org-bullets
#+begin_src emacs-lisp
;; UTF-8 bullets in Org buffers
(use-package org-bullets
  :after org
  :hook (org-mode . org-bullets-mode)
  :config (setq org-bullets-bullet-list '("■" "◆" "▲" "▶")))
#+end_src

** Display the outline path at point in Org-mode using which-func

Use ~which-func~ to display the outline path where the point is within
the Org-mode document.

This depends on some of the ~which-func~ customization set up in
\S[[Display function or outline node at point using which-func]]
so make sure the code there is loaded first.

#+name: org-which-func
#+begin_src emacs-lisp
(with-eval-after-load 'org
  ;; display the outline path at point using which-func
  (with-eval-after-load 'which-func
    (add-to-list 'which-func-modes 'org-mode)
    (defun my-org-which-function-string-shortener (str &optional maxlen)
      "Shortens STR if it is longer than MAXLEN chars."
      (let* ((len (length str))
             (maxlen (or maxlen 40)) ;; default maxlen of 40
             (num-left-chars (/ maxlen 2))
             (num-right-chars (- maxlen num-left-chars 3)))
        (if (> len maxlen)
            (concat (substring str 0 num-left-chars)
                    "..."
                    (substring str (- len num-right-chars) len))
          str)))
    (defun my-org-which-function ()
      "Returns current outline path."
      (if (eq major-mode 'org-mode)
          (condition-case nil
              (mapconcat #'my-org-which-function-string-shortener
                         (org-get-outline-path t)
                         " > ")
            (error nil))))
    (add-to-list 'which-func-functions #'my-org-which-function)
    ;; Org-specific which-func header
    (defun my-org-narrow-to-subtree-toggle ()
      "Toggle org-narrow-to-subtree."
      (interactive)
      (if (buffer-narrowed-p)
          (widen)
        (org-narrow-to-subtree)))
    (defvar my-which-func-header-keymap-org
      (let ((keymap (make-sparse-keymap)))
        (define-key keymap [header-line mouse-1] 'my-org-narrow-to-subtree-toggle)
        ;; work around mouse-1 mapping to mouse-2 when cursor is on org bullet
        (define-key keymap [header-line mouse-2] 'my-org-narrow-to-subtree-toggle)
        (define-key keymap [header-line mouse-3] 'outline-up-heading)
        (define-key keymap [header-line wheel-up] 'org-backward-heading-same-level)
        (define-key keymap [header-line wheel-down] 'org-forward-heading-same-level)
        keymap)
      "Keymap for header line which-func.")
    (defvar my-which-func-header-keymap-help-text-org
      "mouse-1 : toggle rest visibility\n\
mouse-3 : go up one heading\n\
wheel-u : next same-level heading\n\
wheel-d : prev same-level heading"
      "Help text for `my-which-fun-header-keymap-org'.")
    (defvar my-which-func-header-format-org
      `(:propertize which-func-current
        local-map ,my-which-func-header-keymap-org
        face which-func
        mouse-face mode-line-highlight
        help-echo my-which-func-header-keymap-help-text-org))
    ;; add Org-mode which-func header to lookup assoc list, see init-ui.el
    (add-to-list 'my-which-func-header-formats `(org-mode . ,my-which-func-header-format-org))))
#+end_src

** Org entrypoint hydra                                               :hydra:

Hydra providing entrypoints to multiple Org-mode functions.

#+name: org-entrypoints-hydra
#+begin_src emacs-lisp
;; hydra for Org entrypoints
(defhydra my-hydra/org-entrypoints (:color teal :columns 4)
  "
Org (_q_: quit)"
  ("q" nil nil)
  ("a" org-agenda "agenda")
  ("c" org-capture "capture")
  ("b" org-switchb "switch buffer")
  ("l" org-store-link "store link"))

;; bind Org entrypoints hydra
(global-set-key (kbd "C-c C-M-o") #'my-hydra/org-entrypoints/body)
#+end_src

** Org-mode hydra                                                     :hydra:

Major mode-specific hydra for ~org-mode~.

#+name: org-mode-hydra
#+begin_src emacs-lisp
;; hydra for org-mode
(defhydra my-hydra/org-mode (:color amaranth :columns 3)
  "
Org-mode (_q_: quit)"
  ("q" nil nil :exit t)
  ("M-s" org-narrow-to-subtree "narrow-subtree")
  ("M-b" org-narrow-to-block "narrow-block")
  ("M-w" widen "widen")
  ("M-l" org-toggle-link-display "toggle-link-disp")
  ("M-i" (lambda ()
           (interactive)
           (if org-image-actual-width
               (setq org-image-actual-width nil)
             (setq org-image-actual-width (list (/ (display-pixel-width) 3))))
           (org-redisplay-inline-images)) "toggle-img-width")
  ("i" org-toggle-inline-images "toggle-images")
  ("I" org-indent-mode "toggle-indent")
  ("P" org-toggle-pretty-entities "toggle-prettify")
  ("<tab>" org-cycle "cycle")
  ("<S-tab>" org-global-cycle "global-cycle")
  ("/" org-sparse-tree "sparse-tree")
  ("c" org-remove-occur-highlights "occur-clear")
  ("p" (lambda (n)
         (interactive "p")
         (if org-occur-highlights
             (previous-error n)
           (org-previous-visible-heading n)))
   "previous")
  ("n" (lambda (n)
         (interactive "p")
         (if org-occur-highlights
             (next-error n)
           (org-next-visible-heading n)))
   "next")
  ("g" org-goto "goto" :exit t)
  ("s" org-sort "sort" :exit t)
  ("o" org-occur "occur" :exit t)
  ("r" org-refile "refile" :exit t)
  ("t" org-todo "state" :exit t)
  (":" org-set-tags-command "tags" :exit t)
  ("," org-priority "priority" :exit t)
  ("D" org-insert-drawer "drawer" :exit t)
  ("P" org-set-property "property" :exit t)
  ("N" org-add-note "note" :exit t)
  ("F" org-footnote-action "footnote" :exit t)
  ("a" org-archive-subtree-default "archive" :exit t)
  ("<" org-insert-structure-template "structure" :exit t)
  ("'" org-edit-special "edit-special" :exit t)
  ("e" my-hydra/org-mode/emphasize/body "→ Emphasize" :exit t))

;; hydra for org-mode text formatting
(defhydra my-hydra/org-mode/emphasize (:color teal :columns 4)
  "
Org-mode → Emphasize (_q_: ←)"
  ("q" my-hydra/org-mode/body nil)
  ("b" (org-emphasize ?*) "bold")
  ("i" (org-emphasize ?/) "italic")
  ("u" (org-emphasize ?_) "underline")
  ("s" (org-emphasize ?+) "strike-through")
  ("c" (org-emphasize ?~) "code")
  ("v" (org-emphasize ?=) "verbatim"))

;; binding for org-mode hydra
(with-eval-after-load 'org
  (define-key org-mode-map (kbd "C-c C-M-m") #'my-hydra/org-mode/body))
#+end_src

** org-download for dragging and dropping images into Org-mode

*** org-download hydra                                                :hydra:

Hydra for ~org-download~.
Add an entrypoint for the hydra to the org-mode hydra.

#+name: org-download-hydra
#+begin_src emacs-lisp
(when (display-graphic-p)
  ;; hydra for org-download
  (defhydra my-hydra/org-mode/download (:color teal :columns 3)
    "
Org-mode → Download (_q_: ←)"
    ("q" my-hydra/org-mode/body nil)
    ("s" org-download-screenshot "screenshot")
    ("y" org-download-yank "yank"))

  ;; add entrypoint to download hydra to the org-mode hydra
  (defhydra+ my-hydra/org-mode nil
    ("d" my-hydra/org-mode/download/body "→ Download" :exit t)))
#+end_src

** org-present for minimalist presentations within Emacs

*** Add Org-mode presentation head to org-mode hydra                  :hydra:

Add head for initializing an ~org-present~ presentation to org-mode
hydra.

#+name: add-org-present-to-org-mode-hydra
#+begin_src emacs-lisp
;; add org-present present head to org-mode hydra
(defhydra+ my-hydra/org-mode nil
  ("C-p" (lambda ()
           (interactive)
           (let ((in-present-mode (condition-case nil
                                      org-present-mode
                                    (error nil))))
             (if in-present-mode (org-present-quit) (org-present))))
   "org-present" :exit t))
#+end_src

** Org Agenda hydra                                                   :hydra:

Major mode-specific hydra for ~org-agenda-mode~.

#+name: org-agenda-hydra
#+begin_src emacs-lisp
;; mode-specific hydra for org-agenda-mode
(defhydra my-hydra/org-agenda-mode (:color amaranth :hint nil)
  "
Org agenda (_q_: quit)
Headline    _ht_  : set status   _hk_  : kill         _hr_  : refile
            _hA_  : archive      _h:_  : set tags     _hp_  : set priority
Visit Entry _SPC_ : other window _TAB_ : & go to loc  _RET_ : & del other wins
            _o_   : link
Date        _ds_  : schedule     _dd_  : set deadline _dt_  : timestamp
View        _vd_  : day          _vw_  : week         _vm_  : month
            _vn_  : next span    _vp_  : prev span    _vr_  : reset
Filter      _ft_  : by tag       _fc_  : by category  _fh_  : by top headline
            _fx_  : by regex     _fd_  : reset
Clock       _ci_  : in           _co_  : out          _cq_  : cancel
            _cg_  : goto
Other       _gr_  : reload       _gd_  : go to date   _._   : go to today
            _sd_  : hide done
"
  ("q" nil nil :exit t)
  ("ht" org-agenda-todo)
  ("hk" org-agenda-kill)
  ("hr" org-agenda-refile)
  ("hA" org-agenda-archive-default)
  ("h:" org-agenda-set-tags)
  ("hp" org-agenda-priority)
  ("SPC" org-agenda-show-and-scroll-up)
  ("TAB" org-agenda-goto :exit t)
  ("RET" org-agenda-switch-to :exit t)
  ("o" link-hint-open-link :exit t)
  ("ds" org-agenda-schedule)
  ("dd" org-agenda-deadline)
  ("dt" org-agenda-date-prompt)
  ("vd" org-agenda-day-view)
  ("vw" org-agenda-week-view)
  ("vm" org-agenda-month-view)
  ("vn" org-agenda-later)
  ("vp" org-agenda-earlier)
  ("vr" org-agenda-reset-view)
  ("ft" org-agenda-filter-by-tag)
  ("fc" org-agenda-filter-by-category)
  ("fh" org-agenda-filter-by-top-headline)
  ("fx" org-agenda-filter-by-regexp)
  ("fd" org-agenda-filter-remove-all)
  ("ci" org-agenda-clock-in :exit t)
  ("co" org-agenda-clock-out)
  ("cq" org-agenda-clock-cancel)
  ("cg" org-agenda-clock-goto :exit t)
  ("gr" org-agenda-redo)
  ("gd" org-agenda-goto-date)
  ("." org-agenda-goto-today)
  ("sd" (lambda () (interactive)
          (progn (setq org-agenda-skip-scheduled-if-done
                       (if org-agenda-skip-scheduled-if-done nil t))
                 (org-agenda-redo-all t)))))

;; bind org-agenda-mode hydra
(with-eval-after-load 'org-agenda
  (define-key org-agenda-mode-map (kbd "C-c C-M-m") #'my-hydra/org-agenda-mode/body))
#+end_src

** org-noter for document annotation                                  :melpa:

[[https://github.com/weirdNox/org-noter][Org-noter]] allows the creation of external synchronized notes for
documents viewed using [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Document-View.html][DocView]], [[https://github.com/politza/pdf-tools][PDF Tools]] or [[https://depp.brause.cc/nov.el/][Nov.el]].

Use ~C-c N~ or ~M-x org-noter~ while in an Org document or when
viewing a document in the above tools to annotate.

When annotating in the split-screen mode:
- ~i~ inserts a note approximately (document buffer-only).
- ~M-i~ inserts a precise note (document buffer-only).
- ~q~ exits the annotation session (document buffer-only).
- ~M-n~ goes to the next page.
- ~M-p~ goes to the previous page.
- ~C-M-n~ goes to the next note.
- ~C-M-p~ goes to the previous note.

#+name: org-noter
#+begin_src emacs-lisp
;; create sychronized external notes in DocView and Nov.el
(use-package org-noter
  :bind ("C-c N" . org-noter)
  :init (setq org-noter-always-create-frame nil))
#+end_src

** org-present for minimalist presentations within Emacs              :melpa:

[[https://github.com/rlister/org-present][org-present]] extends org-mode so that it can be used for minimalist
presentations within Emacs.

Each top-level heading will correspond to a presentation slide.
=LEFT= and =RIGHT= will move forward and backward through the
slides, and =C-c C-q= will quit the presentation.

*Customizations*:
- Hide header and mode lines when presentation is active.
- Additional keybindings during presentation
  - =UP=/=DOWN=: Scroll up/down.
  - =SHIFT-UP=/=SHIFT-DOWN=: Go to top/bottom of slide.
  - =SHIFT-LEFT=/=SHIFT-RIGHT=: Go to first/last slide.
  - =f=: Toggle fullscreen.
  - =q=: Quit presentation (like =C-c C-q=).
  - =-=: Decrease text scale.
  - =+=: Increase text scale.

#+name: org-present
#+begin_src emacs-lisp
;; in-editor presentations using Org documents
(use-package org-present
  :after org
  :hook ((org-present-mode . (lambda ()
                               (org-present-big)
                               (org-display-inline-images)
                               (org-present-read-only)
                               (my-hide-header-and-mode-lines)))
         (org-present-mode-quit . (lambda ()
                                    (org-present-small)
                                    (org-remove-inline-images)
                                    (org-present-read-write)
                                    (my-unhide-header-and-mode-lines))))
  :config
  ;; regenerate LaTeX fragment preview images on slide transition
  (when (and (display-graphic-p)
             (executable-find "dvipng"))
    (add-hook 'org-present-after-navigate-functions
              (lambda (&optional name header)
                (my-org-display-latex-fragments))))
  ;; functions for hiding header and mode lines when in a presentation
  (defvar-local my-orig-mode-line-format nil
    "Temporary variable to store original `mode-line-format'.")
  (defvar-local my-orig-header-line-format nil
    "Temporary variable to store original `header-line-format'.")
  (defun my-hide-header-and-mode-lines ()
    "Hide header and mode lines, and store originals in temporary variables."
    (interactive)
    (when mode-line-format
      (setq-local my-orig-mode-line-format mode-line-format)
      (setq-local mode-line-format nil))
    (when header-line-format
      (setq-local my-orig-header-line-format header-line-format)
      (setq-local header-line-format nil)))
  (defun my-unhide-header-and-mode-lines ()
    "Reset header and mode lines using originals in temporary variables."
    (interactive)
    (when (not mode-line-format)
      (setq-local mode-line-format my-orig-mode-line-format)
      (setq-local my-orig-mode-line-format nil))
    (when (not header-line-format)
      (setq-local header-line-format my-orig-header-line-format)
      (setq-local my-orig-header-line-format nil)))
  ;; easier nav keys for read-only presentations
  (define-minor-mode my-org-present-extra-mode
    "Overlay minor mode on top of org-present-mode with easier nav keys."
    :keymap (let ((keymap (make-sparse-keymap)))
              ;; <left>/<right> = previous/next slide
              (define-key keymap (kbd "<up>") 'scroll-down-line)
              (define-key keymap (kbd "<down>") 'scroll-up-line)
              (define-key keymap (kbd "s-<up>") 'beginning-of-buffer)
              (define-key keymap (kbd "s-<down>") 'end-of-buffer)
              (define-key keymap (kbd "s-<left>") 'org-present-beginning)
              (define-key keymap (kbd "s-<right>") 'org-present-end)
              (define-key keymap (kbd "f") 'toggle-frame-fullscreen)
              (define-key keymap (kbd "q") 'org-present-quit)
              (define-key keymap (kbd "-") 'text-scale-decrease)
              (define-key keymap (kbd "+") 'text-scale-increase)
              keymap))
  ;; toggle minor mode after the relevant org-present funcalls
  (advice-add 'org-present-read-only
              :after (lambda () (my-org-present-extra-mode 1)))
  (advice-add 'org-present-read-write
              :after (lambda () (my-org-present-extra-mode 0))))
#+end_src

** org-super-agenda                                                   :melpa:

[[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] groups agenda items into sections.

#+name: org-super-agenda
#+begin_src emacs-lisp
(use-package org-super-agenda
  :config
  (setq org-super-agenda-groups '((:name "Up next"
                                   :todo "NEXT"
                                   :order 1)
                                  (:name "Waiting"
                                   :todo "WAIT"
                                   :order 10)
                                  (:name "On hold"
                                   :todo "HOLD"
                                   :order 11)
                                  (:name "Overdue"
                                   :deadline past
                                   :order 2)
                                  (:name "Due today"
                                   :deadline today
                                   :order 3)
                                  (:name "Today"
                                   :time-grid t
                                   :scheduled today
                                   :order 4)
                                  (:name "Important"
                                   :priority "A"
                                   :order 5)
                                  (:name "Due soon"
                                   :deadline future
                                   :order 6)
                                  (:name "Backlog"
                                   :scheduled past
                                   :order 7)
                                  (:name "Upcoming"
                                   :scheduled future
                                   :order 8)
                                  (:name "Unprioritized"
                                   :priority<= "B"
                                   :order 9)))
  (org-super-agenda-mode 1))
#+end_src

** Org basic capture templates

#+name: org-capture-templates
#+begin_src emacs-lisp
;; Org capture templates
(setq org-capture-templates '(("t" "Todo" entry (file my-org-agenda-inbox)
                               "* TODO %i%?\n%U")
                              ("r" "Respond" entry (file my-org-agenda-inbox)
                               "* NEXT Respond to %i%?\n%U")
                              ("i" "Interrupt Task" entry (file my-org-agenda-inbox)
                               "* NEXT %i%?\n%U"
                               :jump-to-captured t :clock-in t :clock-resume t)
                              ("n" "Note" entry (file my-org-agenda-inbox)
                               "* %i%? :note:\n%U")
                              ("s" "Someday" entry (file my-org-agenda-inbox)
                               "* %i%? :someday:\n%U")
                              ("l" "Link" entry (file my-org-agenda-inbox)
                               "* %a%?\n%U")
                              ("y" "Paste" entry (file my-org-agenda-inbox)
                               "* %?\n%U\n%c")))
#+end_src

** org-journal for journaling using Org-mode               :workaround:melpa:

[[https://github.com/bastibe/org-journal][org-journal]] extends journaling capabilities to Org-mode.

*Note*: Adding journal files are added to the Org agenda can result in
slowdown as the number of files increases. An alternative is to use
~org-store-link~ to store an Org link to the heading, create a new
todo entry using ~org-capture~, and paste/yank the Org link in the
todo entry using ~C-c C-l~.

#+name: org-journal
#+begin_src emacs-lisp
;; journaling using Org documents
(use-package org-journal
  :after org
  :init
  (setq org-journal-file-format "%Y%m%d.org"
        org-journal-file-header (mapconcat 'identity
                                           '("#+TITLE: Daily Journal"
                                             "#+DATE: %d %B %Y"
                                             "#+FILETAGS: journal"
                                             "")
                                           "\n")
        org-journal-file-type 'daily
        ;; don't carry over TODO items from a previous days
        org-journal-carryover-items nil
        ;; use ORG-DIRECTORY/journal/ as the default journal directory
        org-journal-dir (concat org-directory "journal/")
        ;; cache entries to speed up calendar operations, reset cache
        ;; with `org-journal-invalidate-cache'
        org-journal-enable-cache t)
  ;; org-capture helper function from https://github.com/bastibe/org-journal
  (defun my-org-journal-find-location ()
    "Find location of today's Org journal, for use with `org-capture'."
    ;; open today's journal but specify a non-nil prefix argument in order to
    ;; inhibit inserting the heading; org-capture will insert the heading.
    (org-journal-new-entry t)
    (org-narrow-to-subtree)
    (goto-char (point-max)))
  ;; add org-capture template for new journal entries
  ;; capture template type should be plain instead of entry, see
  ;; https://www.reddit.com/r/orgmode/comments/goivjp/orgcapture_template_doesnt_insert_entry_as_a/
  ;; (add-to-list 'org-capture-templates
  ;;              '("j" "Journal" plain (function my-org-journal-find-location)
  ;;                "** %(format-time-string org-journal-time-format)%?\n%i")
  ;;              t)
  ;; add journal files to Org agenda
  ;; may cause the Org agenda parsing to slow down as the number as
  ;; the number of files grows, so make sure to prune or archive the
  ;; files elsewhere every so often if this is enabled
  ;; to limit to just current and future (i.e. scheduled) journal
  ;; entries, set `org-journal-enable-agenda-integration' to t instead
  ;; (push org-journal-dir org-agenda-files)
  :config
  ;; workaround on `org-journal-is-journal' `string-match' error when
  ;; exporting to HTML due to `buffer-file-name' func returning nil
  ;; this also fixes an issue matching file paths when the journal
  ;; file path contains a symlink since the pattern generated by
  ;; `org-journal--dir-and-file-format->pattern' resolves symlinks in
  ;; `org-journal-dir', so the org-journal file path contains symlinks
  ;; while the pattern has those symlinks resolved and
  ;; `org-journal-is-journal' returns nil when it should return t
  (defun org-journal-is-journal--around-workaround (orig-fun &rest args)
    "Drop-in replacement advice function for `org-journal-is-journal'."
    (let* ((buf-file-name-raw (buffer-file-name))
           (buf-file-name (if buf-file-name-raw
                              (file-truename buf-file-name-raw)
                            ""))) ; default to empty string if not a file buffer
      (string-match (org-journal--dir-and-file-format->pattern)
                    buf-file-name)))
  (advice-add 'org-journal-is-journal :around
              #'org-journal-is-journal--around-workaround))
#+end_src

* Programming

** Flymake syntax checker (old)

*** Flymake hydra                                                     :hydra:

Hydra for Flymake.

#+name: flymake-hydra
#+begin_src emacs-lisp
;; hydra for Flymake
(defhydra my-hydra/flymake (:color amaranth :columns 4)
  "
Flymake (_q_: quit)"
  ("q" nil nil :exit t)
  ("p" flymake-goto-prev-error "prev-err")
  ("n" flymake-goto-next-error "next-err")
  ("l" my-toggle-flymake-diagnostics "list")
  ("s" flymake-start "start-check"))

;; binding for Flymake hydra
(with-eval-after-load 'flymake
  (define-key flymake-mode-map (kbd "C-c C-M-!") #'my-hydra/flymake/body))
#+end_src

** Flycheck syntax checker (old)

*** Flycheck hydra                                                    :hydra:

Hydra for Flycheck.

#+name: flycheck-hydra
#+begin_src emacs-lisp
;; flycheck hydra
(defhydra my-hydra/flycheck (:color amaranth :columns 3)
  "
Flycheck [checker=%s(if flycheck-checker (symbol-name flycheck-checker) \"default\")] (_q_: quit)"
  ("q" nil nil :exit t)
  ("c" flycheck-buffer "run")
  ("C" flycheck-clear "clear")
  ("C-c" flycheck-compile "compile")
  ("n" flycheck-next-error "next")
  ("p" flycheck-previous-error "previous")
  ("l" (condition-case nil (quit-windows-on "*Flycheck errors*" t)
         (error (flycheck-list-errors))) "list")
  ("H" display-local-help "local-help")
  ("h" flycheck-display-error-at-point "display-at-pt")
  ("e" flycheck-explain-error-at-point "explain-at-pt")
  ("s" flycheck-select-checker "select-checker")
  ("?" flycheck-describe-checker "describe-checker" :exit t)
  ("v" flycheck-verify-setup "verify-setup" :exit t)
  ("C-w" flycheck-copy-errors-as-kill "copy-errors")
  ("i" flycheck-manual "web-manual" :exit t))

;; binding for flycheck hydra
(with-eval-after-load 'flycheck
  (define-key flycheck-mode-map (kbd "C-c C-M-!") #'my-hydra/flycheck/body))
#+end_src

** Flycheck syntax checker                                            :melpa:

[[https://www.flycheck.org/en/latest/][Flycheck]] ([[https://github.com/flycheck/flycheck][Github]]) is an on-the-fly syntax checker for Emacs that is a
popular alternative to the built-in [[https://elpa.gnu.org/packages/flymake.html][Flymake]] package.

If using this, it is typical to not enable Flymake.

#+name: flycheck
#+begin_src emacs-lisp
;; linting support, used in place of FlyMake
(use-package flycheck
  :init
  ;; customizations:
  ;; - remove newlines from events triggering linting checks
  ;; - don't mark error lines in fringe or margin
  (setq flycheck-check-syntax-automatically '(save
                                              idle-change
                                              mode-line)
        flycheck-indication-mode nil)
  :config
  ;; automatically adjust idle delay before automatically checking the
  ;; buffer depending on whether there are outstanding syntax errors;
  ;; check less frequently if there were no errors, and check more
  ;; frequently if there were errors; have this behavior be per-buffer
  (make-variable-buffer-local 'flycheck-idle-change-delay)
  (defun flycheck--adjust-flycheck-idle-change-delay ()
    "Adjust `flycheck-idle-change-delay' to check less frequently
when buffer is clean, and more frequently when it has errors."
    (setq flycheck-idle-change-delay (if flycheck-current-errors
                                         0.5
                                       3.0)))
  (add-hook 'flycheck-after-syntax-check-hook
            #'flycheck--adjust-flycheck-idle-change-delay)
  ;; default modes within which to use Flycheck
  (add-hook 'emacs-lisp-mode-hook #'flycheck-mode))
#+end_src

** Devskim and Flycheck                                            :external:

[[https://github.com/Microsoft/DevSkim/][DevSkim]] is a collection of static analyzers that does code security
analysis.

If it is installed on the system, there is a Flycheck [[https://github.com/microsoft/DevSkim/tree/main/flycheck][backend]]
distributed with the official codebase (add to a directory in
~load-path~ and load it when initializing Emacs). It does not run by
default for the supported modes (C, C++ and Python), and has to be
chained to the checker that is run for those modes. For example,
~(flycheck-add-next-checker 'lsp 'devskim)~ if using ~lsp-mode~ is
used as the main checker for the mode.

#+name: flycheck-devskim
#+begin_src emacs-lisp
(when (executable-find "devskim")
  (use-package flycheck-devskim
    :ensure nil ;; in site-lisp subfolder within user emacs directory
    :config
    (setq flycheck-devskim-executable "devskim")
    (with-eval-after-load 'lsp-diagnostics
      (defun lsp-diagnostics--flycheck-enable--after-add-devskim (&rest _)
       "Chain devskim checker on the lsp checker after it is enabled."
       (flycheck-add-next-checker 'lsp 'devskim))
     (advice-add 'lsp-diagnostics--flycheck-enable :after
                 #'lsp-diagnostics--flycheck-enable--after-add-devskim))))
#+end_src

** Conda package and environment manager

*** Conda hydra                                                       :hydra:

Hydra for conda.

#+name: conda-hydra
#+begin_src emacs-lisp
(defhydra my-hydra/conda (:color teal :columns 4)
  "
conda (_q_: quit)"
  ("q" nil nil)
  ("a" conda-env-activate "activate")
  ("d" conda-env-deactivate "deactivate")
  ("l" conda-env-list "list"))
(with-eval-after-load 'conda
  (global-set-key (kbd "C-c C-M-S-v") 'my-hydra/conda/body))
#+end_src

** lsp-mode Language Server Protocol Client                           :melpa:

*** Workaround for stale Flymake error reports                   :workaround:

In certain scenarios, the language server diagnostics before Flymake changes the reporting function and new diagnostics are ignored while old errors continue being reported, leading to stale error reports. See [[https://github.com/emacs-lsp/lsp-mode/pull/1423][Github issue]].

#+name: lsp-mode-flymake-stale-errors-workaround
#+begin_src emacs-lisp
;; redefine lsp--flymake to work around scenarios where the LS sends
;; diagnostics before Flymake changes the reporting function and new
;; diagnostics are ignored while old errors continue being reported
;; https://github.com/emacs-lsp/lsp-mode/pull/1423
(with-eval-after-load 'lsp-mode
  (defun lsp--flymake-backend (report-fn &rest _args)
    "Flymake backend."
    (let ((first-run (null lsp--flymake-report-fn)))
      (setq lsp--flymake-report-fn report-fn)
      (lsp--flymake-update-diagnostics))))
#+end_src

*** lsp-mode hydra                                                    :hydra:

Hydra for lsp-mode.

#+name: lsp-mode-hydra
#+begin_src emacs-lisp
;; hydras adapted from lsp-mode's default command map, see lsp-command-map in
;; https://github.com/emacs-lsp/lsp-mode/blob/master/lsp-mode.el
(defhydra my-hydra/lsp (:color teal :columns 3)
  "
Language Server (_q_: quit)"
  ("q" nil nil)
  ("s" my-hydra/lsp-session/body "→ Session")
  ("=" my-hydra/lsp-format/body "→ Format")
  ("F" my-hydra/lsp-folder/body "→ Folder")
  ("T" my-hydra/lsp-toggle/body "→ Toggle")
  ("g" my-hydra/lsp-goto/body "→ Goto")
  ("h" my-hydra/lsp-help/body "→ Help")
  ("r" my-hydra/lsp-refactor/body "→ Refactor")
  ("a" my-hydra/lsp-actions/body "→ Actions")
  ("I" (lambda ()
         (interactive)
         (lsp-install-server t))
   "install"))
(defhydra my-hydra/lsp-session (:color teal :columns 3)
  "
Language Server → Session (_q_: ←)"
  ("q" my-hydra/lsp/body nil)
  ("r" (condition-case nil (lsp-restart-workspace) (error (lsp))) "(re-)start")
  ("s" lsp-workspace-shutdown "shutdown")
  ("d" lsp-describe-session "describe")
  ("D" lsp-disconnect "disconnect"))
(defhydra my-hydra/lsp-format (:color teal :columns 3)
  "
Language Server → Format (_q_: ←)"
  ("q" my-hydra/lsp/body nil)
  ("=" lsp-format-buffer "buffer")
  ("r" lsp-format-region "range"))
(defhydra my-hydra/lsp-folder (:color teal :columns 3)
  "
Language Server → Folder (_q_: ←)"
  ("q" my-hydra/lsp/body nil)
  ("a" lsp-workspace-folders-add "add")
  ("r" lsp-workspace-folders-remove "remove")
  ("b" lsp-workspace-blacklist-remove "un-blacklist"))
(defhydra my-hydra/lsp-toggle (:color amaranth :columns 3)
  "
Language Server → Toggle (_q_: ←)"
  ("q" my-hydra/lsp/body nil :exit t)
  ("l" lsp-lens-mode "lens-mode")
  ("L" lsp-toggle-trace-io "trace-io")
  ("h" lsp-toggle-symbol-highlight "symbol-highlight")
  ("b" lsp-headerline-breadcrumb-mode "headerline-breadcrumb")
  ("s" lsp-toggle-signature-auto-activate "signature-help")
  ("f" lsp-toggle-on-type-formatting "on-type-formatting"))
(defhydra my-hydra/lsp-goto (:color teal :columns 3)
  "
Language Server → Goto (_q_: ←)"
  ("q" my-hydra/lsp/body nil)
  ("j" (lambda ()
         (interactive)
         (if (fboundp 'imenu-list-smart-toggle)
             (imenu-list-smart-toggle)
           (message "Requires imenu-list"))) "imenu")
  ("g" lsp-find-definition "definition")
  ("r" lsp-find-references "references")
  ("i" lsp-find-implementation "implementation")
  ("t" lsp-find-type-definition "type-implementation")
  ("d" lsp-find-declaration "declaration")
  ("a" xref-find-apropos "workspace-symbol"))
(defhydra my-hydra/lsp-help (:color teal :columns 3)
  "
Language Server → Help (_q_: ←)"
  ("q" my-hydra/lsp/body nil)
  ("h" lsp-describe-thing-at-point "describe")
  ("s" lsp-signature-activate "signature-activate"))
(defhydra my-hydra/lsp-refactor (:color teal :columns 3)
  "
Language Server → Refactor (_q_: ←)"
  ("q" my-hydra/lsp/body nil)
  ("r" lsp-rename "rename")
  ("o" lsp-organize-imports "organize-imports"))
(defhydra my-hydra/lsp-actions (:color teal :columns 3)
  "
Language Server → Actions (_q_: ←)"
  ("q" my-hydra/lsp/body nil)
  ("a" lsp-execute-code-action "execute-code-action")
  ("l" lsp-avy-lens "avy-lens")
  ("h" lsp-document-highlight "document-highlight"))

;; bind lsp-mode hydra
(with-eval-after-load 'lsp-mode
  (define-key lsp-mode-map (kbd "C-c C-M-l") #'my-hydra/lsp/body))
#+end_src

** dap-mode Debug Adaptor Protocol client

*** Add entry points for dap-mode functions to lsp hydra              :hydra:

Add ~dap-debug~ and ~dap-debug-edit-template~ to main lsp hydra.

#+name: add-dap-mode-funs-to-lsp-mode-hydra
#+begin_src emacs-lisp
;; add dap-mode debugging function entry points to lsp-mode hydra
(with-eval-after-load 'lsp-mode
  (defhydra+ my-hydra/lsp nil
    ("d" dap-debug "dap-debug" :exit t)
    ("D" dap-debug-edit-template "dap-template" :exit t)))
#+end_src

** Bash and sh shell scripts

*** ShellCheck shell script static analyzer and Flycheck

[[https://github.com/koalaman/shellcheck][ShellCheck]] is a static analyzer for Bash and sh scripts. Flycheck has
built-in support for it. It can be installed using MacPorts or Conda (with the binary symlinked in one of the ~$PATH~ directories).

#+name: shellcheck
#+begin_src emacs-lisp
;; automatically enable Flycheck mode when shellcheck is installed
(when (executable-find "shellcheck")
  (with-eval-after-load 'flycheck
    (add-hook 'sh-mode-hook #'flycheck-mode)))
#+end_src

** Emacs Lisp

*** Emacs Lisp profiler hydra                                         :hydra:

Hydra for built in Emacs [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Profiling.html][profiler]].

#+name: profiler-hydra
#+begin_src emacs-lisp
;; hydra for built-in Emacs Lisp profiler
(defhydra my-hydra/profiler (:color teal :columns 3
                             :pre (require 'profiler))
  "
Emacs profiler [CPU=%(profiler-running-p) MEM=%(profiler-memory-running-p)] (_q_: quit)"
  ("q" nil nil)
  ("s" profiler-start "start/reset" :exit nil)
  ("p" profiler-report "report")
  ("e" profiler-stop "stop" :exit nil))

;; binding for Emacs profiler hydra
(global-set-key (kbd "C-c C-M-S-e") 'my-hydra/profiler/body)
#+end_src

*** Emacs Lisp debugger hydra                                         :hydra:

Hydras for [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Debugging.html][debugging]] Emacs Lisp.
One is for changing when the debugger is invoked.
The other is a mode-specific hydra.

#+name: debugger-hydra
#+begin_src emacs-lisp
;; hydra for built-in Emacs Lisp debugger
(defhydra my-hydra/debugger (:color teal :hint nil
                             :pre (require 'debug))
  "
Emacs debugger settings (_q_: quit)
Toggle    _1_ : debug-on-error (currently: %`debug-on-error)
          _2_ : debug-on-quit  (currently: %`debug-on-quit)
Functions _fl_ : list functions to invoke debugger on entry
          _fa_ : add debugger invocation to function
          _fc_ : cancel debugger invocation from function
Variables _vl_ : list variables to invoke debugger on change
          _va_ : add debugger invocation to variable on change
          _vc_ : cancel debugger invocation from variable on change
"
  ("q" nil nil)
  ("1" toggle-debug-on-error :exit nil)
  ("2" toggle-debug-on-quit :exit nil)
  ("fl" debugger-list-functions)
  ("fa" debug-on-entry)
  ("fc" cancel-debug-on-entry)
  ("vl" (lambda () (interactive) (prin1 (debug--variable-list))))
  ("va" debug-on-variable-change)
  ("vc" cancel-debug-on-variable-change))

;; binding for debugger-settings hydra
(global-set-key (kbd "C-c C-M-S-d") 'my-hydra/debugger/body)
#+end_src

#+name: debugger-mode-hydra
#+begin_src emacs-lisp
;; mode-specific hydra for debugger
(defhydra my-hydra/debugger-mode (:color teal :columns 4)
  "
Emacs debugger (_q_: quit)"
  ("q" nil nil)
  ("c" debugger-continue "continue")
  ("d" debugger-step-through "step")
  ("b" debugger-frame "frame")
  ("u" debugger-frame-clear "no-frame")
  ("j" debugger-jump "jump")
  ("e" debugger-eval-expression "eval-expr")
  ("R" debugger-record-expression "record-expr")
  ("Q" top-level "quit-to-top")
  ("r" debugger-return-value "return-val")
  ("l" debugger-list-functions "list-funs")
  ("v" debugger-toggle-locals "list-vars")
  ("h" describe-mode "help"))

;; binding for debugger hydra
(with-eval-after-load 'debug
  (define-key debugger-mode-map (kbd "C-c C-M-m") #'my-hydra/debugger-mode/body))
#+end_src

** Clojure (old)

*** CIDER for a more complete Clojure development environment (old)

**** CIDER hydra                                                      :hydra:

Mode-specific Hydra for accessing CIDER in ~clojure-mode~.

#+name: cider-hydra
#+begin_src emacs-lisp
;; hydras, adapted from https://github.com/clojure-emacs/cider-hydra
(defhydra my-hydra/cider (:color teal :columns 3)
  "
CIDER (_q_: quit)"
  ("q" nil nil)
  ;; start a REPL and connect to it
  ("j" cider-jack-in-clj "jack-in-clj")
  ("s" cider-jack-in-cljs "jack-in-cljs")
  ("b" cider-jack-in-clj&cljs "jack-in-clj&cljs")
  ;; sub-hydras
  ("d" my-hydra/cider-doc/body "→ Documentation")
  ("e" my-hydra/cider-eval/body "→ Evaluation")
  ("T" my-hydra/cider-test/body "→ Test")
  ("D" my-hydra/cider-debug/body "→ Debug")
  ("r" my-hydra/cider-repl/body "→ REPL"))
(defhydra my-hydra/cider-doc (:color teal :columns 4)
  "
CIDER → Documentation (_q_: ←)"
  ("q" my-hydra/cider/body nil)
  ;; CiderDoc
  ("d" cider-doc "cider-docs")
  ;; ClojureDocs
  ("r" cider-clojuredocs "clojure-docs")
  ("h" cider-clojuredocs-web "clojure-docs-web")
  ;; JavaDoc
  ("j" cider-javadoc "java-docs-web")
  ;; apropos
  ("a" cider-apropos "search-symbols")
  ("s" cider-apropos-select "select-symbols")
  ("A" cider-apropos-documentation "search-docs")
  ("e" cider-apropos-documentation-select "select-docs"))
(defhydra my-hydra/cider-eval (:color teal :columns 3)
  "
CIDER → Eval (_q_: ←)"
  ("q" my-hydra/cider/body nil)
  ;; load
  ("k" cider-load-buffer "load-buffer")
  ("l" cider-load-file "load-file")
  ("p" cider-load-all-project-ns "load-all-proj-ns")
  ;; eval
  ("r" cider-eval-region "eval-region")
  ("n" cider-eval-ns-form "eval-ns-form")
  ("e" cider-eval-last-sexp "eval-last-sexp")
  ("P" cider-pprint-eval-last-sexp "eval-last-sexp-pp")
  ("w" cider-eval-last-sexp-and-replace "eval-last-sexp-replace")
  ("E" cider-eval-last-sexp-to-repl "eval-last-sexp-to-repl")
  ("d" cider-eval-defun-at-point "eval-defun-at-point")
  ("f" cider-pprint-eval-defun-at-point "eval-defun-at-point-pp")
  (":" cider-read-and-eval "read-and-eval")
  ;; inspect
  ("i" cider-inspect "inspect")
  ;; macro expansion
  ("m" cider-macroexpand-1 "macroexpand-1")
  ("M" cider-macroexpand-all "macroexpand-all"))
(defhydra my-hydra/cider-test (:color teal :columns 4)
  "
CIDER → Test (_q_: ←)"
  ("q" my-hydra/cider/body nil)
  ("t" cider-test-run-test "run")
  ("l" cider-test-run-loaded-tests "run-loaded")
  ("p" cider-test-run-project-tests "run-project")
  ("n" cider-test-run-ns-tests "run-ns")
  ("r" cider-test-rerun-failed-tests "rerun-failed")
  ("s" cider-test-show-report "show-report"))
(defhydra my-hydra/cider-debug (:color teal :columns 3)
  "
CIDER → Debug (_q_: ←)"
  ("q" my-hydra/cider/body nil)
  ("x" (lambda () (interactive) (cider-eval-defun-at-point t)) "eval-defun-at-pt")
  ("v" cider-toggle-trace-var "toggle-var-trace")
  ("n" cider-toggle-trace-ns "toggle-ns-trace"))
(defhydra my-hydra/cider-repl (:color teal :columns 3)
  "
CIDER → REPL (_q_: ←)"
  ("q" my-hydra/cider/body nil)
  ;; connection
  ("d" cider-display-connection-info "disp-conn-info")
  ("r" cider-rotate-default-connection "rot-default-conn")
  ;; input
  ("z" cider-switch-to-repl-buffer "switch-to-repl")
  ("n" cider-repl-set-ns "set-repl-ns")
  ("p" cider-insert-last-sexp-in-repl "ins-last-sexp-in-repl")
  ("x" cider-refresh "refresh")
  ;; output
  ("o" cider-find-and-clear-repl-output "clear-repl-output")
  ("O" (lambda () (interactive) (cider-find-and-clear-repl-output t)) "clear-repl-all")
  ;; interrupt or quit connected REPL
  ("b" cider-interrupt "interrupt")
  ("Q" cider-quit "quit-cider"))

;; binding for main CIDER hydra
(with-eval-after-load 'clojure-mode
  (define-key clojure-mode-map (kbd "C-c C-M-m") #'my-hydra/cider/body))
#+end_src

*** flycheck-clj-kondo for Clojure linting using clj-kondo   :melpa:external:

[[https://github.com/borkdude/flycheck-clj-kondo][flycheck-clj-kondo]] provides [[https://github.com/borkdude/clj-kondo][clj-kondo]] (a linter for Clojure code)
integration with Flycheck.

#+name: flycheck-clj-kondo
#+begin_src emacs-lisp
;; clojure linting, requires clj-kondo be installed on the system
(when (executable-find "clj-kondo")
  (use-package flycheck-clj-kondo
    :after (flycheck clojure-mode)
    :config
    (require 'flycheck-clj-kondo)
    ;; start flycheck-mode
    (add-hook 'clojure-mode-hook (lambda () (flycheck-mode 1)) t)))
#+end_src

** Python

*** Enable Flycheck mode when editing Python files

Enable Flycheck mode as the last function in the Python mode hook.
When using ~lsp-mode~ in Python buffers, this is unnecessary as
~lsp-mode~ starts ~flycheck-mode~ automatically.

#+name: python-flycheck
#+begin_src emacs-lisp
(add-hook 'python-mode-hook #'flycheck-mode t)
#+end_src

*** Enable Flymake mode when editing Python files

Enable Flymake mode as the last function in the Python mode hook.

#+name: python-flymake
#+begin_src emacs-lisp
(add-hook 'python-mode-hook #'flymake-mode t)
#+end_src

*** Configuring [[https://elpa.gnu.org/packages/flymake.html][Flymake]] to use [[https://www.pylint.org/][Pylint]]

1. Use [[https://github.com/karlotness/flymake-quickdef][Flymake-Quickdef]] to create a new Pylint backend for Flymake.
2. Create a function that adds the new backend to the list of Flymake backends.
3. Add that function to the ~python-mode-hook~.

*** Enable Flymake DevSkim backend when editing Python buffers     :external:

Enable the Flymake DevSkim back when editing Python buffers (see
\S[[Security linting using DevSkim and Flymake]]).

#+name: python-devskim-flymake
#+begin_src emacs-lisp
(when (executable-find "devskim")
  (with-eval-after-load 'flymake-quickdef
    (add-hook 'python-mode-hook #'flymake-devskim-setup)))
#+end_src

*** Enable which-func and Imenu menubar entry in Python buffers

When editing Python buffers, enable which-func and add an Imenu
entry to the menubar.

#+name: python-which-func-imenu
#+begin_src emacs-lisp
;; show function at point
(with-eval-after-load 'which-func
  (add-to-list 'which-func-modes 'python-mode))

;; add Imenu index to menubar
(with-eval-after-load 'imenu
  (add-hook 'python-mode-hook 'imenu-add-menubar-index))
#+end_src

*** Microsoft Python Language Server support with lsp-mode            :melpa:

Use ~lsp-mode~ as a client for the Microsoft Python Language Server.

#+name: lsp-python-ms
#+begin_src emacs-lisp
;; lsp-mode client for MS Python LS, https://github.com/emacs-lsp/lsp-python-ms
(use-package lsp-python-ms
  ;; append lsp-mode hooks
  :config (add-hook 'python-mode-hook
                    (lambda ()
                      ;; load packages if deferred
                      (require 'lsp-mode)
                      (require 'lsp-python-ms)
                      ;; start LSP client
                      (lsp-mode))
                    t))
#+end_src

**** Installing the Microsoft Python Language Server               :external:

- Using ~M-x lsp-python-ms-update-server~ to download it into the
  =.cache/lsp= subdirectory within ~user-emacs-directory~, which can
  be automated by setting ~lsp-python-auto-install-server~ to ~t~.
- Building from [[https://github.com/Microsoft/python-language-server][source]] and setting ~lsp-python-ms-executable~ to the
  path of the compiled binary during Emacs initialization.

*** yapfify for formatting Python buffers with yapf                   :melpa:

[[https://github.com/JorisE/yapfify][yapfify]] creates a convenience functions ~yapfify-buffer~,
~yapfify-region~ and ~yapfify-region-or-buffer~ for using [[https://github.com/google/yapf][yapf]] to
format a Python buffer or region.

It also provides a minor mode ~yapf-mode~ that automically runs ~yapf~
prior to saving a file.

#+name: yapfify
#+begin_src emacs-lisp
;; convenience functions for running yapf on Python buffers/regions
(use-package yapfify)
#+end_src

**** Add yapfify commands to python-mode hydra                        :hydra:

Add entry point to ~yapfify-buffer-or-region~ to python-mode hydra.

#+name: add-yapfify-to-python-mode-hydra
#+begin_src emacs-lisp
;; add entry point to yapfify in python-mode hydra
(defhydra+ my-hydra/python-mode nil
  ("y" yapfify-region-or-buffer "yapf" :exit t))
#+end_src

*** Python hydra                                                      :hydra:

Mode-specific Hydra for Python mode.

#+name: python-mode-hydra
#+begin_src emacs-lisp
;; mode-specific hydra for Python mode
(defhydra my-hydra/python-mode (:color teal :columns 4)
  "
Python (_q_: quit)"
  ("q" nil nil)
  ;; python repl
  ("p" run-python "run-python")
  ("s" python-shell-send-string "send-str")
  ("e" python-shell-send-statement "send-stmt")
  ("r" python-shell-send-region "send-rgn")
  ("x" python-shell-send-defun "send-def")
  ("c" python-shell-send-buffer "send-buf")
  ("l" python-shell-send-file "send-file")
  ("z" python-shell-switch-to-shell "switch-to-sh")
  ;; indentation
  ("<" python-indent-shift-left "indent-l" :exit nil)
  (">" python-indent-shift-right "indent-r" :exit nil)
  ;; utilities
  ("v" python-check "check-err")
  ("f" python-eldoc-at-point "eldoc-at-pt")
  ("d" python-describe-at-point "descr-at-pt")
  ;; other
  ("j" imenu "imenu")
  ("D" pdb "pdb"))

;; binding for Python hydra
(with-eval-after-load 'python
  (define-key python-mode-map (kbd "C-c C-M-m") #'my-hydra/python-mode/body))
#+end_src

*** Python buffer reformatter using black

**** Add Python reformatter commands to python-mode hydra             :hydra:

Add entry point to ~python-black-format-buffer~ and toggle for
~python-black-format-on-save-mode~ to python-mode hydra.

#+name: add-python-black-format-to-python-mode-hydra
#+begin_src emacs-lisp
;; add entry point to yapfify in python-mode hydra
(defhydra+ my-hydra/python-mode nil
  ("y" (lambda ()
         (interactive)
         (python-black-format-buffer-or-region))
   "format" :exit t)
  ("Y" python-black-format-on-save-mode "format-on-save"))
#+end_src

*** Live Coding in Python                                             :melpa:

[[https://donkirkby.github.io/live-py-plugin/][Live Coding in Python]] ([[https://github.com/donkirkby/live-py-plugin][Github]]) provides a minor mode ~live-py-mode~
that supports live coding, similar to the coding environment described
in [[http://worrydream.com/][Bret Victor]]'s [[http://worrydream.com/#!/InventingOnPrinciple][Inventing on Principle]] talk ([[https://github.com/ezyang/cusec2012-victor/blob/master/transcript.md][transcript]]).

When enabled, Python code will be run as it is being typed and a side
window with a live coding buffer opened that visualizes the results.

#+name: live-py-mode
#+begin_src emacs-lisp
;; live coding in python
(use-package live-py-mode)
#+end_src

**** Add toggle for live-py-mode to python-mode hydra                 :hydra:

Add an entry point to ~live-py-mode~ in the python-mode hydra,
that toggles python live coding.

#+name: add-live-py-mode-to-python-mode-hydra
#+begin_src emacs-lisp
;; add live-py-mode toggle to python-mode hydra
(defhydra+ my-hydra/python-mode nil
  ("L" live-py-mode "live-py-mode" :exit t))
#+end_src

** R

*** ess-mode hydra                                                    :hydra:

Hydra for ~ess-mode~.

#+name: ess-mode-hydra
#+begin_src emacs-lisp
;; major mode-specific hydra for ess-mode
(defhydra my-hydra/ess-mode (:color teal :hint nil)
  "
Emacs Speaks Statistics (_q_: quit)
Session       _N_ : new       _R_ : request   _s_ : switch    _C-q_ : quit
Eval          _l_ : line      _f_ : func      _r_ : region    _b_   : buffer
Workspace     _D_ : chdir     _d_ : R dired
Help          _h_ : object    _H_ : browser   _A_ : apropos
"
  ("q" nil nil)
  ;; session
  ("N" (lambda () (interactive)
         (cond ((string= ess-dialect "R") (R))
               ((string= ess-dialect "julia") (julia))
               (t (message "Unsupported dialect")))))
  ("R" ess-request-a-process)
  ("s" ess-switch-to-ESS)
  ("C-q" ess-quit)
  ;; eval
  ("l" ess-eval-line)
  ("f" ess-eval-function)
  ("r" ess-eval-region)
  ("b" ess-eval-buffer)
  ;; workspace
  ("D" ess-change-directory)
  ("d" ess-rdired)
  ;; help
  ("h" ess-display-help-on-object)
  ("H" ess-display-help-in-browser)
  ("A" ess-display-help-apropos))

;; binding for ess-mode hydra
(with-eval-after-load 'ess-mode
  (define-key ess-mode-map (kbd "C-c C-M-m") #'my-hydra/ess-mode/body))
#+end_src

** Racket

*** racket-mode hydra                                                 :hydra:

Mode-specific hydra for ~racket-mode~.

#+name: racket-mode-hydra
#+begin_src emacs-lisp
;; major mode-specific hydra for racket-mode
(defhydra my-hydra/racket-mode (:color teal :columns 4)
  "
Racket Mode (_q_: quit)"
  ("q" nil nil)
  ;; refactoring requires
  ("Rt" racket-tidy-requires "tidy-req")
  ("RT" racket-trim-requires "trim-req")
  ("Rb" racket-base-requires "base-req")
  ;; compile Racket Mode's .rkt files for faster startup
  ("S" racket-mode-start-faster "mode-compile")
  ;; racket modes
  ("x" racket-xp-mode "xp-mode" :exit nil)
  ;; repl
  ("rr" racket-run "run")
  ("rm" racket-run-module-at-point "run-module")
  ("rR" racket-racket "racket")
  ;; profiling and logging
  ("rp" racket-profile "profile")
  ("rl" racket-logger "logger")
  ;; testing
  ("t" racket-test "test")
  ("T" racket-raco-test "raco-test")
  ;; misc
  ("f" racket-find-collection "find-coll")
  ;; help
  ("." racket-xp-visit-definition "visit-defn")
  ("C-." racket-visit-module "visit-modl")
  ("," racket-unvisit "unvisit")
  ("h" racket-xp-describe "desc")
  ("H" racket-xp-documentation "docs")
  ;; editing
  ("a" racket-align "align")
  ("A" racket-unalign "unalign"))

;; bindings for racket-mode hydra
(with-eval-after-load 'racket-mode
  (define-key racket-mode-map (kbd "C-c C-M-m") #'my-hydra/racket-mode/body))
#+end_src

** SQL

*** ejc-sql to query databases using Clojure JDBC connections :external:melpa:

[[https://github.com/kostafey/ejc-sql][ejc-sql]] is a SQL client that uses Clojure JDBC connections to connect
to databases.

It uses Clojure and so requires [[https://leiningen.org/][Leiningen]] be installed.

Note that support for ~company-mode~ is currently experimental.

The appropriate JDBC drivers may need to be installed using Maven. For
more information, see the package website.

Connection definitions should go into the =lisp/init-local.el= file in
~user-emacs-directory~ that is loaded at startup in this config.

#+name: ejc-sql
#+begin_src emacs-lisp
;; database SQL client using Clojure JDBC
(use-package ejc-sql
  :commands (ejc-connect ejc-connect-existing-repl ejc-sql-mode)
  :bind (:map ejc-sql-mode-keymap
         ("C-g" . nil) ; unbind C-g in mode-map shadowing regular C-g
         ("C-c C-k" . ejc-cancel-query)) ; rebind to C-c C-k instead
  :init
  ;; use `completing-read' for minibuffer completion
  ;; change ejc-sql keymap prefix to "C-c s" (from the default "C-c e")
  (setq ejc-completion-system 'standard
        ejc-keymap-prefix (kbd "C-c s"))
  :config
  ;; ejc-sql setup code
  (defun my-ejc-sql-minor-mode-setup ()
    "Setup code to run when `ejc-sql-minor-mode' is enabled.
This enables things like ElDoc and autocompletion."
    (company-mode 1) ; use company-mode for autocompletion
    (ejc-eldoc-setup)) ; set up Eldoc support
  (add-hook 'ejc-sql-minor-mode-hook #'my-ejc-sql-minor-mode-setup))
#+end_src

** Dyalog APL

Add [[https://github.com/harsman/dyalog-mode][support]] for editing [[https://www.dyalog.com/][Dyalog APL]] files and integration with
[[https://www.dyalog.com/dyalog/development-environment.htm][Dyalog RIDE]] (built-in integrated development environment).

Also add an input method for entering APL glyphs in Emacs using Dyalog
RIDE bindings. This package is sourced from [[https://github.com/abochannek/Dyalog/tree/master/dyalog-apl-input][here]]. See [[https://aplwiki.com/wiki/Typing_glyphs][this link]] for
more information on entering APL glyphs.

Connect to a Dyalog RIDE session using ~dyalog-ride-session~.

#+name: dyalog-mode
#+begin_src emacs-lisp
;; support for editing Dyalog files and integration with Dyalog RIDE
(use-package dyalog-mode
  :config
  ;; support for entering APL glyphs using Dyalog RIDE bindings
  (use-package dyalog-apl-input
    :ensure nil) ; in site-lisp directory
  ;; setup Dyalog APL buffer-specific editing environment
  (defun dyalog-mode--setup ()
    "Setup code to run when entering a `dyalog-mode' buffer."
    ;; use APL-compatible font
    (my-set-buffer-face-mode-font-family "APL385 Unicode")
    ;; enable Dyalog backtick input method
    (set-input-method "dyalog-apl-prefix"))
  ;; run setup code when entering Dyalog APL buffers
  (add-hook 'dyalog-mode-hook #'dyalog-mode--setup)
  (add-hook 'dyalog-session-mode-hook #'dyalog-mode--setup)
  (add-hook 'dyalog-debugger-mode-hook #'dyalog-mode--setup))
#+end_src

* Project interaction

** Git identity management                                            :melpa:

[[https://github.com/akirak/git-identity.el][git-identity.el]] is a frontend in Emacs for managing Git identities.
This is useful when multiple Git identities need to handled on the
same machine.

It has integration with Magit.

#+name: git-identity
#+begin_src emacs-lisp
;; the "I" key in Magit opens a Git identity management interface
(use-package git-identity
  :after magit
  :bind (:map magit-status-mode-map
         ("I" . git-identity-info))
  :config
  (require 'git-identity-magit)
  (git-identity-magit-mode 1))
#+end_src

** Projectile

*** Projectile hydra                                                  :hydra:

Major mode-specific hydra for interfacing with Projectile commands.

#+name: projectile-hydra
#+begin_src emacs-lisp
;; hydra for Projectile
(defhydra my-hydra/projectile-mode (:color teal :hint nil)
  "
Projectile: %s(projectile-project-name) (_q_: quit)
Buffer _←_ : previous proj buf  _→_ : next proj buf      _b_ : switch
       _I_ : ibuffer            _S_ : save proj bufs     _k_ : kill proj bufs
File   _f_ : find (curr proj)   _F_ : find (known projs) _g_ : find (context)
       _t_ : goto impl/test     _e_ : recent             _E_ : dir-locals-file
Dir    _d_ : find dir           _D_ : dired
Search _o_ : multi-occur        _s_ : grep               _r_ : replace string
Tags   _j_ : find tag           _R_ : regenerate tags
Shell  _x_ : eshell             _!_ : run command        _&_ : run command async
Other  _C_ : configure proj     _c_ : compile proj       _u_ : run proj
       _P_ : test proj          _z_ : cache curr file    _i_ : clear cache
"
  ("q" nil nil)
  ;; buffer
  ("b" projectile-switch-to-buffer)
  ("<left>" projectile-previous-project-buffer :exit nil)
  ("<right>" projectile-next-project-buffer :exit nil)
  ("I" projectile-ibuffer)
  ("S" projectile-save-project-buffers)
  ("k" projectile-kill-buffers)
  ;; file
  ("f" projectile-find-file)
  ("F" projectile-find-file-in-known-projects)
  ("g" projectile-find-file-dwim)
  ("t" projectile-toggle-between-implementation-and-test)
  ("e" projectile-recentf)
  ("E" projectile-edit-dir-locals)
  ;; dir
  ("d" projectile-find-dir)
  ("D" projectile-dired)
  ;; search
  ("o" projectile-multi-occur)
  ("s" projectile-grep)
  ("r" projectile-replace)
  ;; tags
  ("j" projectile-find-tag)
  ("R" projectile-regenerate-tags)
  ;; other
  ("C" projectile-configure-project)
  ("c" projectile-compile-project)
  ("u" projectile-run-project)
  ("P" projectile-test-project)
  ("z" projectile-cache-current-file)
  ("i" projectile-invalidate-cache)
  ("x" projectile-run-eshell)
  ("!" projectile-run-shell-command-in-root)
  ("&" projectile-run-async-shell-command-in-root)
  ;; misc
  ("m" projectile-commander "commander")
  ("p" projectile-switch-project "switch project"))

;; binding for projectile hydra
(with-eval-after-load 'projectile
  (define-key projectile-mode-map (kbd "C-c C-M-p") #'my-hydra/projectile-mode/body))
#+end_src

** Treemacs

*** Treemacs all-the-icons integration

Use icons from all-the-icons in Treemacs.

#+name: treemacs-all-the-icons
#+begin_src emacs-lisp
;; use icons from all-the-icons in Treemacs
(use-package treemacs-all-the-icons
  :after (treemacs all-the-icons)
  :config
  (treemacs-load-theme "all-the-icons")
  ;; reduce tab-width to fix spacing between icons and text
  (add-hook 'treemacs-mode-hook
            (lambda () (setq-local tab-width 2))))
#+end_src

* Reference management

** ebib for managing BibTeX databases                                 :melpa:

*** Ebib Org-mode support

Configure Org-mode support for Ebib.

*Configuration*:
- Add new Org link type supporting ebib key lookup and preamble,
  pre-note and post-note text for the reference, with the format being
  =[[ebib:key][Preamble text::Pre-note::Post-note]]= where
  ~key~ should be a valid key in the =.bib= file currently open in ebib.
- ~C-c C-M-S-b i~ calls ~ebib-insert-citation~ in Org-mode buffers.

#+name: ebib-org-mode-config
#+begin_src emacs-lisp
;; configure Ebib Org-mode support
;;
;; this setup supports exporting Org to PDF with BibTeX bibliographies via
;; lualatex and biber, so they will need to be installed on the system
;;
;; org-mode documents should include the LaTeX headers for
;; bibliographies via "#+LATEX_HEADER:" structural markup elements,
;; and "\printbibliography" should be added at the desired location
;; for the bibliography (usually at the end of an article or book
;; chapter or before the index)
;;
;; references to bibliography entries in org-mode can be inserted by
;; pressing `i' when on an entry in ebib or by calling
;; `ebib-insert-citation'
;;
;; to export references from Org to LaTeX, ebib needs to be opened with the
;; bibliographies for the references that appear in the document
;;
;; use "::" in the Org link description to separate the preamble text,
;; pre-note, and post-note elements (all optional) for export to LaTeX,
;; i.e. "[[ebib:key][Preamble text::Pre-note::Post-note]]"
;; will export to "Preamble text\cite[Pre-note][Post-note]{key}"
;;
;; example:
;; ---
;; ...
;; #+LATEX_HEADER: \usepackage[backend=biber]{biblatex}
;; #+LATEX_HEADER: \addbibresource{path/to/bibtex_file.bib}
;; ...
;; [[ebib:some_ebib_entry_key]]
;; [[ebib:some_ebib_entry_key][Preamble]
;; [[ebib:some_ebib_entry_key][Preamble::::Post-note]
;; [[ebib:some_ebib_entry_key][Preamble::Pre-note::Post-note]]
;; [[ebib:incognito_1970][::see::pg. 99]]
;; ...
;; \printbibliography
;; ...
;; ---
;;
(with-eval-after-load 'org
  ;; ebib configuration for org-mode
  (with-eval-after-load 'ebib
    (require 'org-ebib)
    (defun my-org-ebib-export (path desc format)
      "Export an ebib link. See `org-link-parameters' for details about PATH, DESC and FORMAT."
      (let* ((my-desc (or desc ""))
             (desc-parts (split-string my-desc "::"))
             (desc-name (car desc-parts))
             (desc-pre-note (or (nth 1 desc-parts) ""))
             (desc-post-note (mapconcat 'identity (nthcdr 2 desc-parts) "::")))
        (cond
         ((eq format 'html)
          (if desc
              (format "(%s<cite>%s</cite>%s)"
                      (if (string= "" desc-pre-note) "" (concat desc-pre-note " "))
                      (if (string= "" desc-name) path desc-name)
                      (if (string= "" desc-post-note) "" (concat ", " desc-post-note)))
            (format "(<cite>%s</cite>)" path)))
         ((eq format 'latex)
          (if desc
              (format "%s\\cite%s%s{%s}"
                      (concat desc-name " ")
                      (if (string= "" desc-pre-note) "" (format "[%s]" desc-pre-note))
                      (if (string= "" desc-post-note) "" (format "[%s]" desc-post-note))
                      path)
            (format "\\cite{%s}" path))))))
    (org-link-set-parameters "ebib" :export 'my-org-ebib-export))
  ;; binding for `ebib-insert-citation'
  (define-key org-mode-map (kbd "C-c C-M-S-b i") #'ebib-insert-citation))
#+end_src

* Search

** Search hydra                                                       :hydra:

Hydra for easier access to Emacs [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Search.html][search]] functionality.

#+name: search-hydra
#+begin_src emacs-lisp
(defhydra my-hydra/search (:color teal :columns 3)
  "
Search (_q_: quit)"
  ("q" nil nil)
  ("gg" grep "grep")
  ("gr" rgrep "rgrep")
  ("gl" lgrep "lgrep")
  ("gf" grep-find "grep-find")
  ("gz" rzgrep "rzgrep")
  ("oo" occur "occur")
  ("om" multi-occur "multi-occur")
  ("ob" multi-occur-in-matching-buffers "multi-occur-match-buf")
  ("rs" query-replace "replace string")
  ("rr" query-replace-regexp "replace regexp")
  ("kg" kill-grep "kill-grep")
  ("." (lambda ()
         (interactive)
         (call-interactively #'xref-find-definitions))
   "xref-find-def"))
(global-set-key (kbd "C-c C-M-/") 'my-hydra/search/body)
#+end_src

** Helm occur bindings in search hydra                                :hydra:

Bind over the ~occur~ entry in the search hydra. Since the search
hydra is only defined later, the binding action is added to the
post-initialization hook.

#+name: add-helm-occur-to-search-hydra
#+begin_src emacs-lisp
;; bind over occur entry with helm-occur in search hydra
(with-eval-after-load 'helm
  (defhydra+ my-hydra/search nil
    ("oo" helm-occur "occur")
    ("ov" helm-occur-visible-buffers "occur-visible")))
#+end_src

** Ripgrep support                                           :hydra:external:

Support for [[https://github.com/BurntSushi/ripgrep][ripgrep]], an alternative for the grep search tool that is
extremely fast.
Besides having its own binding, also add a hydra head for calling it
to the [[Search hydra]].

It has an editing mode ~deadgrep-edit-mode~ (still not mature) that
can can be enabled within deadgrep buffers somewhat like [[https://github.com/mhayashi1120/Emacs-wgrep][wgrep.el]].
This allows the direct editing of the deadgrep buffer, after which
running ~M-x deadgrep-mode~ propogates the changes back to the
files and the buffer is switched back to ~deadgrep-mode~.

#+name: ripgrep-support
#+begin_src emacs-lisp
;; support for ripgrep if installed on the system
(when (executable-find "rg")
  (use-package deadgrep
    :defer t
    :bind ("<f5>" . deadgrep))
  (defhydra+ my-hydra/search nil
    ("gR" deadgrep "ripgrep" :exit t)))
#+end_src

** rg.el entrypoint in search hydra                                   :hydra:

Add rg.el entrypoint to the search hydra.

#+name: search-hydra-rg
#+begin_src emacs-lisp
(when (executable-find "rg")
  (defhydra+ my-hydra/search nil
    ("R" rg-menu "ripgrep" :exit t)))
#+end_src

** dumb-jump hydra                                                    :hydra:

Hydra for ~dumb-jump~.

~dumb-jump-mode~ is a minor mode that enables three bindings:
- ~C-M-g~ to jump to the definition of the thing under point.
- ~C-M-p~ to jump backwards.
- ~C-M-q~ to show definition of the thing under point in a tooltip.

#+name: dumb-jump-hydra
#+begin_src emacs-lisp
;; hydra for dumb-jump
;; adapted from https://github.com/jacktasia/dumb-jump/blob/master/README.md
(defhydra my-hydra/search/dumb-jump (:color teal :columns 3
                                     :pre (require 'dumb-jump))
  "
Dumb Jump [mode-enabled=% 3`dumb-jump-mode] (_q_: ←)"
  ("q" my-hydra/search/body nil)
  ("j" dumb-jump-go "go")
  ("o" dumb-jump-go-other-window "go-other")
  ("e" dumb-jump-go-prefer-external "go-ext")
  ("x" dumb-jump-go-prefer-external-other-window "go-ext-other")
  ("i" dumb-jump-go-prompt "prompt")
  ("l" dumb-jump-quick-look "peek")
  ("b" dumb-jump-back "back" :exit nil)
  ("m" dumb-jump-mode "toggle-mode" :exit nil))

;; add entrypoint for dumb-jump hydra in my-hydra/search
(defhydra+ my-hydra/search nil
  ("j" my-hydra/search/dumb-jump/body "dumb-jump"))
#+end_src

** Notdeft for searching notes and other text files

[[https://github.com/hasu/notdeft][Notdeft]] is an Emacs mode for quickly searching and managing
directories of files, utilizing [[https://xapian.org/][Xapian]] for indexing.

*** Installing Notdeft                                             :external:

Clone ~notdeft~ into a build directory (change =~/build= as needed).
This can be a new directory in one of the ~load-path~ directories,
for example the =site-lisp= subdirectory in ~user-emacs-directory~.

#+begin_example
$ cd ~/.emacs.d/site-lisp
$ git clone https://github.com/hasu/notdeft.git
#+end_example

Install build dependencies and compile the ~notdeft-xapian~ backend.
The following shows installing of build dependencies using MacPorts
(modify the dependency installation step as needed if using another
package manager).

#+begin_example
$ sudo port install tclap xapian
$ cd notdeft
$ make
$ cd xapian
$ make
#+end_example

If notdeft was not cloned and built to a subdirectory in ~load-path~
(like the =site-lisp= folder in ~user-emacs-directory~), make a
shallow copy (no ~.git~ directory) or create a softlink to a
~load-path~ directory.

The following shows the softlink approach
(replace =~/.emacs.d/site-lisp= as appropriate).

#+begin_example
$ ln -s ~/build/notdeft ~/.emacs.d/site-lisp
#+end_example

*** Configuring Notdeft

*Configuration*:
- Use the =journal= and =scratch= subdirectories in the Org
  directory (specified by the ~org-directory~ variable).
- Use Org documents as primary file format, supporting text and
  Markdown as secondary file formats.
- Set the path to the =notdeft-xapian= compiled binary.

#+name: notdeft
#+begin_src emacs-lisp
;; load notdeft if installed, make sure org-directory is set prior
(require 'notdeft-autoloads nil t)
(when (featurep 'notdeft-autoloads)
  (setq notdeft-directories `(,(concat org-directory "journal/")
                              ,(concat org-directory "scratch/"))
        notdeft-extension "org"
        notdeft-secondary-extensions '("md" "txt")
        notdeft-directory (concat org-directory "scratch/")
        notdeft-xapian-program (concat (file-name-directory
                                        (locate-library "notdeft"))
                                       "xapian/notdeft-xapian"))
  ;; binding to access Notdeft
  (global-set-key (kbd "C-c N") #'notdeft))
#+end_src

** Show match counts with Anzu                                        :melpa:

[[https://github.com/emacsorphanage/anzu][anzu.el]] provides a minor mode that shows the total number of matches
when searching and the current match number.

*Warning*:
This can be pretty slow in large buffers.
Consider turning off this mode for the buffer in those cases.

#+name: anzu
#+begin_src emacs-lisp
;; show current and total search matches, and preview query replace results
(use-package anzu
  :bind (([remap query-replace] . anzu-query-replace)
         ([remap query-replace-regexp] . anzu-query-replace-regexp))
  :init (setq anzu-mode-lighter "" ; don't show in mode line since always activated
              anzu-deactivate-region t) ; deactivate region after replacing text
  :config (global-anzu-mode))
#+end_src

* Visual

** Outline minor mode hydra                                           :hydra:

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Outline-Mode.html][Outline mode]] is a mode for visualizing and editing the outline structure
of documents.
It provides commands to navigate the outline structure and to hide
text that are not heading lines (i.e. folding code).
The navigation commands are:
- ~C-c C-n~ and ~C-c C-p~ navigate to the next and previous visible
  headings.
- ~C-c C-f~ and ~C-c C-b~ navigate to the next and previous visible
  headings of the same level.
- ~C-c C-u~ navigates to the parent heading of the current one.

Outline mode can be enabled as a major mode or a minor mode.
The minor mode is typically the more useful of the two, so define a
hydra to access its visualization commands in a user friendly manner.

#+name: outline-hydra
#+begin_src emacs-lisp
;; hydra for toggling outline-minor-mode and running its commands
(defhydra my-hydra/visual/outline (:color amaranth :hint nil
                                   :pre (require 'outline))
  "
Visual → Outline [minor-mode-enabled=%`outline-minor-mode] (_q_: ←)
Mode    _m_ : toggle
Hide    _c_ : entry     _l_ : leaves    _d_ : subtree   _o_ : other
        _t_ : body
Show    _e_ : entry     _i_ : children  _k_ : branches  _s_ : subtree
        _a_ : all
"
  ("q" my-hydra/visual/body nil :exit t)
  ("c" outline-hide-entry)
  ("l" outline-hide-leaves)
  ("d" outline-hide-subtree)
  ("t" outline-hide-body)
  ("o" outline-hide-other)
  ("e" outline-show-entry)
  ("i" outline-show-children)
  ("k" outline-show-branches)
  ("s" outline-show-subtree)
  ("a" outline-show-all)
  ("m" outline-minor-mode))

;; add entry-point into outline hydra from visual hydra
(defhydra+ my-hydra/visual nil
  ("o" my-hydra/visual/outline/body "→ Outline" :exit t))
#+end_src

** Tab-cycling of folds in outline-minor-mode with outline-magic      :melpa:

[[https://github.com/tj64/outline-magic][outline-magic]] extends outline-mode and outline-minor-mode with
visibility cycling and structural editing.

Emulate the node visibility cycling of Org mode, where pressing ~TAB~
while on an outline heading with cycle its subtree visibility.

#+name: outline-magic
#+begin_src emacs-lisp
;; <tab> cycles the folding of the current node in outline-minor-mode
;; https://www.reddit.com/r/emacs/comments/a6tu8y/outlineminormode_for_emacs_maybe_useful/eby6c2r/
(use-package outline-magic
  :config
  (add-hook 'outline-minor-mode-hook
            (lambda ()
              (define-key outline-minor-mode-map (kbd "TAB")
                '(menu-item "" nil :filter
                            (lambda (&optional _)
                              (when (outline-on-heading-p)
                                #'outline-cycle)))))))
#+end_src

** Semantic highlighting using color-identifiers-mode                 :melpa:

[[https://github.com/ankurdave/color-identifiers-mode][Color identifiers mode]] provides semantic highlighting, coloring each
source code identifier based on its name (specifically, a symbol or
variable name has the same color wherever it appears in the text).

The configuration below is the default, but two of the main parameters
users can modify are ~color-identifiers-coloring-method~ which
controls how words are mapped to colors and
~color-identifiers:num-colors~ which controls the cardinality of the
colorspace words are mapped to (more is not better since many of the
colors could end up very similar).

#+name: color-identifiers-mode
#+begin_src emacs-lisp
;; provides semantic coloring where same keywords are also colored the same
(use-package color-identifiers-mode
  :config (setq color-identifiers-coloring-method 'sequential
                color-identifiers:num-colors 10))
#+end_src

*** color-identifiers-mode hydra                                      :hydra:

Extend visual hydra to allow toggling of ~color-identifiers-mode~.

#+name: color-identifiers-mode-hydra
#+begin_src emacs-lisp
;; extend visual hydra to support color-identifiers-mode
(eval
 `(defhydra+ my-hydra/visual
    ,(append my-hydra/visual/params '(:pre (require 'color-identifiers-mode)))
    ,(concat my-hydra/visual/docstring
             "_c_  : color-identifiers-mode   [% 3`color-identifiers-mode]
")
    ("c" color-identifiers-mode :exit nil)))
#+end_src

** Display function or outline node at point using which-func     :semiearly:

Display current function or outline node at point using [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Which-Function.html][Which Function mode]].
The mode is customized from its defaults as follows:
- The current function or outline node is displayed in the header line
  instead of the mode line.
- Mouse mappings for the which func part in the header line are
  modified to better support trackpads and support narrowing to the
  current definition or outline node.

#+name: which-func
#+begin_src emacs-lisp
;; display function or outline node at point
(setq which-func-modes '() ;; use `which-func-mode' only for given modes
      which-func-unknown "n/a")

;; enable minor mode
(which-function-mode)

;; modify to show current function in header instead of in mode line

(defun my-narrow-to-defun-toggle ()
  "Toggle narrow to defun."
  (interactive)
  (if (buffer-narrowed-p)
      (widen)
    (narrow-to-defun)))

(defvar my-which-func-header-keymap-default
  (let ((keymap (make-sparse-keymap)))
    (define-key keymap [header-line s-mouse-1] 'my-narrow-to-defun-toggle) ;; trackpad workaround
    (define-key keymap [header-line mouse-2] 'my-narrow-to-defun-toggle)
    (define-key keymap [header-line wheel-up] 'beginning-of-defun)
    (define-key keymap [header-line wheel-down] 'end-of-defun)
    keymap)
  "Keymap for header line which-func.")

(defvar my-which-func-header-keymap-help-text-default
  "mouse-2 : toggle rest visibility\n\
wheel-u : go to beginning\n\
wheel-d : go to end"
  "Help text for `my-which-fun-header-keymap-default'.")

(defvar my-which-func-header-format-default
  `(:propertize which-func-current
                local-map ,my-which-func-header-keymap-default
                face which-func
                mouse-face mode-line-highlight
                help-echo my-which-func-header-keymap-help-text-default)
  "Default header format for which-func part.")

;; remove which-func part from the mode line
(setq mode-line-misc-info (assq-delete-all 'which-function-mode mode-line-misc-info))

;; see Org mode section for a mode-specific example for Org-mode
(defvar my-which-func-header-formats
  `((nil . ,my-which-func-header-format-default))
  "Association list for looking up mode-specific which-func header-lines.
Keys should be major mode symbols and values should unevaluated
mode-line constructs, see
https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Data.html
for more info.")

(defun my-which-func-get-header-format ()
  "Gets `header-line-format' associated with the current major mode in `my-which-func-header-formats'."
  (cdr (or (assoc major-mode my-which-func-header-formats) ;; mode-specific
           (assoc nil my-which-func-header-formats)))) ;; default

(defun which-func-ff-hook--add-which-func-to-header-line ()
  "Add which-func part to header line for major modes in `which-func-modes'."
  (when (memq major-mode which-func-modes)
    (add-to-list 'header-line-format
                 '(which-function-mode
                   (which-func-mode
                    ("[ " (:eval (my-which-func-get-header-format)) " ]"))))))

;; run `which-func-ff-hook--add-which-func-to-header-line' after `which-func-ff-hook'
(advice-add 'which-func-ff-hook
            :after #'which-func-ff-hook--add-which-func-to-header-line)
#+end_src

** Visual hydra                                                       :hydra:

Hydra for manipulating various visual settings.

#+name: visual-hydra
#+begin_src emacs-lisp
;; hydra for visual settings
(defhydra my-hydra/visual (:color amaranth :hint nil
                           :pre (progn
                                  (require 'follow)
                                  (require 'hilit-chg)
                                  (require 'hl-line)
                                  (require 'display-line-numbers)
                                  (require 'face-remap)
                                  (require 'whitespace)))
  "
Visual (_q_: quit)
_b_ : blink-cursor [% 5`blink-cursor-mode]^^^^^   _F_ : follow       [% 5`follow-mode]^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   _f_ : font-lock    [% 5`font-lock-mode]
_H_ : hl-changes   [% 5`highlight-changes-mode]   _h_ : hl-line      [% 5`hl-line-mode]^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   _l_ : line-nums    [% 5`display-line-numbers-mode]
_p_ : show-paren   [% 5`show-paren-mode]^^^^^^^   _s_ : scroll-bar   [% 5(frame-parameter nil 'vertical-scroll-bars)]   _S_ : hscroll-bar  [% 5(frame-parameter nil 'horizontal-scroll-bars)]
_T_ : transient-mk [% 5`transient-mark-mode]^^^   _t_ : truncate-lns [% 5`truncate-lines]^^^^^^^^^^^^^^^^^^^^^^^^^^^^   _v_ : visual-line  [% 5`visual-line-mode]
_W_ : whitespace   [% 5`whitespace-mode]^^^^^^^   _w_ : trailing-ws  [% 5`show-trailing-whitespace]^^^^^^^^^^^^^^^^^^   _m_ : menu-bar     [% 5`menu-bar-mode]
_nr_ / _np_ / _nd_ / _nw_ : narrow to-region / to-page / to-defun / widen      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^[% 5(buffer-narrowed-p)]
_+_  / _-_  / _0_    ^  ^ : zoom   in        / out     / reset                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^[% 5(if text-scale-mode text-scale-mode-amount nil)]
"
  ("q" nil :exit t)
  ("b" blink-cursor-mode)
  ("F" follow-mode)
  ("f" font-lock-mode)
  ("H" highlight-changes-mode)
  ("h" hl-line-mode)
  ("l" display-line-numbers-mode)
  ("m" menu-bar-mode)
  ("p" show-paren-mode)
  ("s" toggle-scroll-bar)
  ("S" toggle-horizontal-scroll-bar)
  ("T" transient-mark-mode)
  ("t" toggle-truncate-lines)
  ("v" visual-line-mode)
  ("W" whitespace-mode)
  ("w" (lambda ()
         (interactive)
         (setq-local show-trailing-whitespace
                     (not show-trailing-whitespace))
         (message "show-trailing-whitespace: %s"
                  (if show-trailing-whitespace "yes" "no"))))
  ("nr" narrow-to-region)
  ("np" narrow-to-page)
  ("nd" narrow-to-defun)
  ("nw" widen)
  ("+" text-scale-increase)
  ("-" text-scale-decrease)
  ("0" (text-scale-adjust 0))
  ("r" (lambda ()
         (interactive)
         ;; refocus doom-modeline just in case
         (when (and (boundp 'doom-modeline-mode)
                    doom-modeline-mode)
           (doom-modeline-focus))
         ;; redraw display
         (redraw-display))
   "redraw"))

(defvar-local my-hydra/visual/emphasis--face-remap-cookies '()
  "Alist storing cookies for `face-remap-add-relative' calls.")

(defun my-hydra/visual/emphasis--toggle-lighten-face (face)
  "Toggle lightening of FACE color for emphasis or emphasis."
  (let ((face-remap-cookie-old (alist-get face my-hydra/visual/emphasis--face-remap-cookies)))
    (if face-remap-cookie-old
        (progn
          (face-remap-remove-relative face-remap-cookie-old)
          (setq my-hydra/visual/emphasis--face-remap-cookies
                (assq-delete-all
                 face
                 my-hydra/visual/emphasis--face-remap-cookies)))
      (let* ((light-color (color-lighten-name
                           (face-attribute face :foreground)
                           50)) ;; lighten color by 50 percent
             (face-remap-cookie-new (face-remap-add-relative
                                     face
                                     :foreground light-color)))
        (push `(,face . ,face-remap-cookie-new)
              my-hydra/visual/emphasis--face-remap-cookies)))))

(defhydra my-hydra/visual/emphasis (:color amaranth :hint nil)
  "
Visual → Emphasis (_q_: quit)
_c_ : comments      [% 3(null (assq 'font-lock-comment-face my-hydra/visual/emphasis--face-remap-cookies))]   _C_ : comment-delim  [% 3(null (assq 'font-lock-comment-delimiter-face my-hydra/visual/emphasis--face-remap-cookies))]   _d_ : doc            [% 3(null (assq 'font-lock-doc-face my-hydra/visual/emphasis--face-remap-cookies))]
"
  ("q" my-hydra/visual/body :exit t)
  ("c" (lambda ()
         (interactive)
         (my-hydra/visual/emphasis--toggle-lighten-face
          'font-lock-comment-face)))
  ("C" (lambda ()
         (interactive)
         (my-hydra/visual/emphasis--toggle-lighten-face
          'font-lock-comment-delimiter-face)))
  ("d" (lambda ()
         (interactive)
         (my-hydra/visual/emphasis--toggle-lighten-face
          'font-lock-doc-face))))

;; bind visual hydra
(global-set-key (kbd "C-c C-M-v") 'my-hydra/visual/body)

;; add entrypoint to visual emphasis hydra to visual hydra
(defhydra+ my-hydra/visual nil
  ("e" my-hydra/visual/emphasis/body "→ Emphasis" :exit t))
#+end_src

** Color coding by depth using prism

*** Prism hydra                                                       :hydra:

Extend visual hydra to support ~prism-mode~ and ~prism-whitespace-mode~.

#+name: prism-hydra
#+begin_src emacs-lisp
;; extend visual hydra to support prism-mode and prism-whitespace-mode
(eval
 `(defhydra+ my-hydra/visual
    ,(append my-hydra/visual/params '(:pre (require 'prism)))
    ,(concat my-hydra/visual/docstring
             "_Pm_ : prism-mode               [% 3`prism-mode]   _Pw_ : prism-whitespace-mode    [% 3`prism-whitespace-mode]
")
    ("Pm" prism-mode :exit nil)
    ("Pw" prism-whitespace-mode :exit nil)))
#+end_src

** Censor text in specific buffers

*** Add censor-mode buffer-local and global toggles to visual hydra   :hydra:

Add ~censor-mode~ and ~global-censor-mode~ toggles to visual hydra.

#+name: add-censor-mode-toggles-to-visual-hydra
#+begin_src emacs-lisp
;; add `censor-mode' and `global-censor-mode' toggles to visual hydra
(eval
 `(defhydra+ my-hydra/visual
    ,(append my-hydra/visual/params '(:pre (require 'censor)))
    ,(concat my-hydra/visual/docstring
             "_X_  : global-censor-mode       [% 3`global-censor-mode]   _x_  : censor-mode              [% 3`censor-mode]
")
    ("X" global-censor-mode :exit nil)
    ("x" censor-mode :exit nil)))
#+end_src

** Add indent guides and symbol overlay toggles to visual hydra       :hydra:

Add ~highlight-indent-guides-mode~ and ~symbol-overlay-mode~ toggles to visual hydra.

Additionally, [[https://github.com/wolray/symbol-overlay][symbol-overlay]] (see the /§Editing Text/ section)
provides a buffer-local minor mode ~symbol-overlay-mode~ that
auto-highlights occurrences of the word at point. Add a toggle for
~symbol-overlay-mode~ to the visual hydra as well.

These are combined to provide two toggles on a single line in the
hydra to minimize excess space usage in the hydra docstring.

#+name: add-indent-guides-symbol-overlay-toggles-to-visual-hydra
#+begin_src emacs-lisp
;; add `highlight-indent-guides-mode' toggle to visual hydra
(eval
 `(defhydra+ my-hydra/visual
    ,(append my-hydra/visual/params
             '(:pre (progn
                      (require 'symbol-overlay)
                      (require 'highlight-indent-guides))))
    ,(concat my-hydra/visual/docstring
             "_O_  : symbol-overlay-mode      [% 3`symbol-overlay-mode]   _i_  : highlight-indent-guides  [% 3`highlight-indent-guides-mode]
")
    ("O" symbol-overlay-mode :exit nil)
    ("i" highlight-indent-guides-mode :exit nil)))
#+end_src

** Hide lines that are too long

*** Add too-long-lines-mode toggle to visual hydra

Add toggle for ~too-long-lines-mode~ to visual hydra.

#+name: add-too-long-lines-mode-toggle-to-visual-hydra
#+begin_src emacs-lisp
;; add `too-long-lines-mode' toggle to visual hydra
(eval
 `(defhydra+ my-hydra/visual
    ,(append my-hydra/visual/params
             '(:pre (progn
                      (require 'too-long-lines-mode))))
    ,(concat my-hydra/visual/docstring
             "_L_  : too-long-lines-mode      [% 3`too-long-lines-mode]
")
    ("L" too-long-lines-mode :exit nil)))
#+end_src

** Add non-visible bottom window dividers for easier mouse resizing

By default for GUI Emacs (at least for the Emacs Mac port), right
window dividers are rendered and can be dragged with the mouse to
resize windows horizontally.

Add non-visible bottom window dividers to also allow vertical window
resizing by dragging the space between two up-down adjacent windows.

#+name: add-bottom-window-dividers
#+begin_src emacs-lisp
;; add non-visible bottom window dividers for mouse-based vertical resizing
(setq window-divider-default-bottom-width (if (eq system-type 'darwin)
                                              6
                                            3)
      window-divider-default-places 'bottom-only)
(let ((fg-color (face-attribute 'default :foreground))
      (bg-color (face-attribute 'default :background)))
  (set-face-attribute 'window-divider nil :foreground bg-color)
  (set-face-attribute 'window-divider-first-pixel nil :foreground bg-color)
  (set-face-attribute 'window-divider-last-pixel nil :foreground bg-color))
(window-divider-mode 1)
#+end_src

** Icon fonts using all-the-icons       :workaround:semiearly:external:melpa:

Icon fonts can be enabled using the [[https://github.com/domtronn/all-the-icons.el][all-the-icons]] package.
These are useful for a few scenarios:
- Fitting more information in the mode line by converting descriptor words into icons.
- Making the interface more visually information and/or appealing (subjective).

Package functionality requires that specific icon fonts be installed
on the system. This can be done automatically by running ~M-x
all-the-icons-install-fonts~, or manually by installing the TTF fonts
from [[https://github.com/domtronn/all-the-icons.el/tree/master/fonts][here]] using the system font manager (for example the Font Book app
on macOS).

#+name: all-the-icons
#+begin_src emacs-lisp
;; font icons
(when (display-graphic-p)
  (use-package all-the-icons
    :config (setq all-the-icons-color-icons nil
                  ;; workaround for doom-modeline getting truncated in certain conditions
                  ;; https://github.com/hlissner/doom-emacs/issues/2967#issuecomment-619319082
                  all-the-icons-scale-factor 1.1)))
#+end_src

** Fancy mode line using doom-modeline           :workaround:semiearly:melpa:

Use [[https://github.com/seagle0128/doom-modeline][doom-modeline]] when not using via a TTY.
Requires the ~all-the-icons~ package.

#+name: doom-modeline
#+begin_src emacs-lisp
;; set custom mode line in graphical Emacs
(when (display-graphic-p)
  ;; fast and fancy minimalist mode line, requires all-the-icons be installed
  (use-package doom-modeline
    :after all-the-icons
    :config
    (setq doom-modeline-buffer-file-name-style 'buffer-name
          doom-modeline-env-version nil
          doom-modeline-height 23 ;; change this based on mode-line face height
          doom-modeline-icon (display-graphic-p)
          doom-modeline-irc nil
          doom-modeline-minor-modes t
          doom-modeline-persp-name nil
          doom-modeline-unicode-fallback t)
    ;; workaround for modeline getting truncated in certain conditions
    ;; https://github.com/hlissner/doom-emacs/issues/2967#issuecomment-619319082
    (doom-modeline-def-modeline 'main
      '(bar workspace-name window-number modals matches buffer-info remote-host buffer-position word-count parrot selection-info)
      '(objed-state misc-info grip debug repl lsp minor-modes input-method indent-info buffer-encoding major-mode process vcs checker "  "))
    ;; hide left margin indicator bar
    ;; (set-face-background 'doom-modeline-bar
    ;;                      (face-background 'mode-line))
    ;; (set-face-background 'doom-modeline-bar-inactive
    ;;                      (face-background 'mode-line-inactive))
    ;; enable mode line
    (doom-modeline-mode 1)))
#+end_src

** Hiding minor modes                                       :semiearly:melpa:

Hide minor modes by default using the [[https://github.com/tarsius/minions][minions]] package behind a pop-up menu, only displaying the most important ones.

#+name: minions
#+begin_src emacs-lisp
(if (display-graphic-p)
    ;; hide minor modes in a menu, access with mouse or `minions-minor-mode-menu'
    (use-package minions
      :init
      ;; modes in minions-direct are always shown
      ;; use UTF-8 mode line lighter
      (setq minions-direct '(overwrite-mode view-mode)
            minions-mode-line-lighter "☰")
      (minions-mode 1)))
#+end_src

** Display mode line in minibuffer                          :semiearly:melpa:

[[https://github.com/kiennq/emacs-mini-modeline][mini-modeline]] displays the mode line in the minibuffer, saving
vertical screen space.

TODO - Figure out how to update echo area only when needed ([[https://github.com/kiennq/emacs-mini-modeline/issues/45][link]]), currently updates every 0.1s which is pretty often

#+name: mini-modeline
#+begin_src emacs-lisp
;; show mode line in minibuffer
(use-package mini-modeline
  :after desktop
  :init
  (setq mini-modeline-truncate-p t ; set to nil to always show full mode line
        mini-modeline-echo-duration 3
        mini-modeline-update-interval 0.1)
  :config
  ;; hide mode line lighter
  (add-to-list 'my-mode-lighter-abbrev-alist '(mini-modeline-mode . "") t)
  ;; custom setup/teardown when enabling/disabling `mini-modeline-mode'
  (defun my-mini-modeline-setup (&rest _)
    "Custom setup to run when enabling `mini-modeline-mode'.

Add `mini-modeline-display' to `pre-redisplay-functions'. This
helps with flickering when `lsp-mode' is enabled."
    (add-hook 'pre-redisplay-functions #'mini-modeline-display))
  (defun my-mini-modeline-teardown (&rest _)
    "Custom teardown to run when disabling `mini-modeline-mode'.

Remove `mini-modeline-display' from `pre-redisplay-functions'."
    (remove-hook 'pre-redisplay-functions #'mini-modeline-display))
  (advice-add 'mini-modeline--enable :after #'my-mini-modeline-setup)
  (advice-add 'mini-modeline--disable :after #'my-mini-modeline-teardown)
  ;; make sure `mini-modeline-mode' is disabled before exiting Emacs,
  ;; else desktop.el doesn't persist the original mode line correctly
  (with-eval-after-load 'desktop
    (add-hook 'desktop-save-hook (lambda () (mini-modeline-mode -1))))
  ;; enable mode
  (mini-modeline-mode 1))
#+end_src

** Temporarily highlight yanked text                                  :melpa:

[[https://github.com/k-talo/volatile-highlights.el][volatile-highlights.el]] provides a minor mode that temporarily
highlights yanked text.

#+name: volatile-highlights
#+begin_src emacs-lisp
(use-package volatile-highlights
  :hook (after-init . volatile-highlights-mode)
  :config
  ;; hide mode line lighter for the mode
  (add-to-list 'my-mode-lighter-abbrev-alist '(volatile-highlights-mode . "")))
#+end_src

* Web

** Browsing

*** Emacs Web Wowser hydra                                            :hydra:

Major mode-specific hydra for Emacs Web Wowser (~eww~).

#+name: eww-hydra
#+begin_src emacs-lisp
;; hydra for Emacs Web Wowser
(defhydra my-hydra/eww-mode (:color teal :columns 3)
  "
Emacs Web Wowser (_q_: quit)"
  ("q" nil nil)
  ("d" eww-download "download-link")
  ("G" eww "search")
  ("o" eww-open-file "open-file")
  ("l" eww-back-url "back")
  ("r" eww-forward-url "forward")
  ("g" eww-reload "reload")
  ("v" eww-view-source "view-source")
  ("w" eww-copy-url "copy-url")
  ("&" eww-browse-with-external-browser "browse-ext")
  ("b" eww-add-bookmark "bookmark-page")
  ("B" eww-list-bookmarks "bookmark-list")
  ("R" eww-readable "readable-only")
  ("F" eww-toggle-fonts "toggle-fonts")
  ("I" my-eww-toggle-images "toggle-images")
  ("M-C" eww-toggle-colors "toggle-colors")
  ("D" eww-toggle-paragraph-direction "toggle-text-dir")
  ("s" eww-switch-to-buffer "eww-switch-buf")
  ("S" eww-list-buffers "eww-list-buf")
  ("H" eww-list-histories "history")
  ("C" url-cookie-list "cookie-list"))

;; binding
(with-eval-after-load 'eww
  (define-key eww-mode-map (kbd "C-c C-M-m") #'my-hydra/eww-mode/body))
#+end_src

**** Helper functions for Emacs Web Wowser hydra

Helper functions for ~eww~:
- Toggle images in ~eww-mode~.

#+name: eww-hydra-helper-functions
#+begin_src emacs-lisp
;; helper function for toggling images in Emacs Web Wowser
(defun my-eww-toggle-images ()
  "Toggle displaying of images when rendering HTML."
  (interactive)
  (setq-local shr-inhibit-images (not shr-inhibit-images))
  (eww-reload)
  (message "Images are now %s" (if shr-inhibit-images "off" "on")))
#+end_src

*** Add eww entry point to search hydra                               :hydra:

Add entry point into eww from search hydra.

#+name: search-hydra-eww
#+begin_src emacs-lisp
;; add eww entry point to search hydra
(defhydra+ my-hydra/search nil
  ("w" eww "eww" :exit t))
#+end_src

** REST development tools

*** restclient.el hydra                                               :hydra:

Major mode-specific hydra for ~restclient-mode~.
The head for pretty printing the JSON response requires the
~json-mode~ package be installed.

#+name: restclient-hydra
#+begin_src emacs-lisp
;; hydra for restclient
(defhydra my-hydra/restclient-mode (:color teal :columns 3)
  "
REST client (_q_: quit)"
  ("q" nil nil)
  ("c" restclient-http-send-current "send")
  ("r" restclient-http-send-current-raw "send-raw")
  ("v" restclient-http-send-current-stay-in-window "send-bg")
  ("n" restclient-jump-next "next" :exit nil)
  ("p" restclient-jump-prev "prev" :exit nil)
  ("." restclient-mark-current "mark")
  ("u" restclient-copy-curl-command "copy-curl")
  ("N" (lambda ()
         (interactive)
         (if (buffer-narrowed-p)
             (widen)
           (restclient-narrow-to-current)))
   "narrow" :exit nil)
  ("f" (lambda ()
         (interactive)
         (require 'json-mode nil t)
         (if (fboundp 'json-mode-pretty-print-dwim)
             (call-interactively 'json-mode-pretty-print-dwim)
           (message "Requires the `json-mode' package be installed.")))
   "fmt-json-rgn"))

;; binding for restclient hydra
(with-eval-after-load 'restclient
  (define-key restclient-mode-map (kbd "C-c C-M-m") #'my-hydra/restclient-mode/body))
#+end_src

* Writing

** Writing hydra                                                      :hydra:

Hydra for writing functions.

#+name: writing-hydra
#+begin_src emacs-lisp
;; hydra for writing functions
(defhydra my-hydra/writing (:color amaranth :hint nil
                            :pre (require 'flyspell))
  "
Writing (_q_: quit)
Flyspell   [% 4(if flyspell-mode (if (eq flyspell-generic-check-word-predicate #'flyspell-generic-progmode-verify) 'prog t) nil)]   _f_ : toggle  _F_ : prog
"
  ("q" nil :exit t)
  ("f" flyspell-mode)
  ("F" flyspell-prog-mode))

;; bindings for writing hydra
(global-set-key (kbd "C-c C-M-S-w") #'my-hydra/writing/body)
#+end_src

** darkroom for workspaces without visual distractions

*** darkroom hydra                                                    :hydra:

Extend visual hydra to support ~darkroom-mode~ and
~darkroom-tentative-mode~.

#+name: darkroom-hydra
#+begin_src emacs-lisp
;; extend visual hydra to support darkroom-mode and darkroom-tentative-mode
(eval
 `(defhydra+ my-hydra/visual
    ,(append my-hydra/visual/params '(:pre (require 'darkroom)))
    ,(concat my-hydra/visual/docstring
             "_dm_ : darkroom-mode            [% 3`darkroom-mode]   _dt_ : darkroom-tentative-mode  [% 3`darkroom-tentative-mode]
")
    ("dm" darkroom-mode :exit nil)
    ("dt" darkroom-tentative-mode :exit nil)))
#+end_src

** dictionary.el for looking up word definitions

*** dictionary.el hydra                                               :hydra:

#+name: dictionary-hydra
#+begin_src emacs-lisp
;; add dictionary entrypoints to writing hydra
(eval
 `(defhydra+ my-hydra/writing
    ,(append my-hydra/writing/params '(:pre (require 'dictionary)))
    ,(concat my-hydra/writing/docstring "Dictionary          _s_ : search  _m_ : match
")
    ("s" dictionary-search :exit t)
    ("m" dictionary-match-words :exit t)))
#+end_src

** Synosaurus in-editor thesaurus

*** Synosaurus hydra                                                  :hydra:

Hydra for Synosaurus.

#+name: synosaurus-hydra
#+begin_src emacs-lisp
;; add synosaurus entrypoints to writing hydra
(eval
 `(defhydra+ my-hydra/writing
    ,(append my-hydra/writing/params '(:pre (require 'synosaurus)))
    ,(concat my-hydra/writing/docstring "Synosaurus [% 4`synosaurus-mode]   _S_ : toggle  _L_ : lookup  _R_ : replace _I_ : insert
")
    ("S" synosaurus-mode :exit nil)
    ("L" synosaurus-lookup :exit t)
    ("R" synosaurus-choose-and-replace :exit t)
    ("I" synosaurus-choose-and-insert :exit t)))
#+end_src

** LanguageTool for grammar checking

*** LanguageTool basic Emacs configuration

**** LanguageTool hydra                                               :hydra:

Hydra for ~langtool~.

#+name: langtool-hydra
#+begin_src emacs-lisp
;; add langtool functions to writing hydra
(eval
 `(defhydra+ my-hydra/writing
    ,(append my-hydra/writing/params '(:pre (require 'langtool)))
    ,(concat my-hydra/writing/docstring "LangTool            _w_ : check   _W_ : done    _l_ : lang    _c_ : correct-buf
")
    ("w" langtool-check nil :exit nil)
    ("W" langtool-check-done nil :exit nil)
    ("l" langtool-switch-default-language nil :exit nil)
    ("c" langtool-correct-buffer nil :exit nil)))
#+end_src

** typo.el for typographical editing

*** Add toggle for typo-mode to writing hydra

Add a toggle for ~typo-mode~ to writing hydra.

#+name: add-typo-mode-toggle-to-writing-hydra
#+begin_src emacs-lisp
;; add toggle for typo-mode to writing hydra
(eval
 `(defhydra+ my-hydra/writing
    ,(append my-hydra/writing/params '(:pre (require 'typo)))
    ,(concat my-hydra/writing/docstring
             "Typography [% 4`typo-mode]   _t_ : toggle
")
    ("t" typo-mode :exit nil)))
#+end_src

** Proselint integration with Flycheck                             :external:

[[https://github.com/amperser/proselint][Proselint]] is a linter for English prose. Flycheck has built-in
integration for this, so there's no additional configuration
necessary. It can be installed using most package managers or via
Conda (with the =proselint= binary symlinked to a ~$PATH~ directory).

** darkroom for workspaces without visual distractions                 :elpa:

[[http://elpa.gnu.org/packages/darkroom.html][darkroom]] provides two minor modes ~darkroom-mode~ and
~darkroom-tentative-mode~ that remove visual distractions.

Turning on any of the modes removes the mode line, increases the text
scale and increases the text margins.

The difference between ~darkroom-tentative-mode~ and ~darkroom-mode~
is that ~darkroom-tentative-mode~ only removes visual distractions if
the Emacs frame contains only one window.

#+name: darkroom
#+begin_src emacs-lisp
;; provides toggleable modes that remove visual distractions
(use-package darkroom
  :config (setq darkroom-text-increase-scale 2))
#+end_src

** Spell checking

*** Flyspell for spell checking in Emacs

**** Choose spelling corrections using completing-read                :melpa:

The default ~flyspell-correct-word-before-point~ command creates a
popup designed for mouse interaction. [[https://github.com/d12frosted/flyspell-correct][flyspell-correct]] provides a
wrapper function that filters the corrections through a
~completing-read~ interface.

#+name: flyspell-correct
#+begin_src emacs-lisp
;; wrapper to filter Flyspell corrections through `completing-read'
(use-package flyspell-correct
  :after flyspell
  :bind (:map flyspell-mode-map
         ("C-c $" . flyspell-correct-wrapper)))
#+end_src

* Other

** Auth sources

The auth-source package provides a API for secure storage and access
of user secrets.
A number of Emacs packages come with support for this, most notably
[[https://www.gnu.org/software/emacs/manual/html_node/gnus/][GNUS]] and [[https://www.gnu.org/software/tramp/][TRAMP]].

#+name: auth-sources
#+begin_src emacs-lisp
;; Auth Sources, https://www.gnu.org/software/emacs/manual/auth.html
(if (file-exists-p "~/.authinfo.gpg")
    (setq auth-sources '((:source "~/.authinfo.gpg" :host t :protocol t)))
  (setq auth-sources '((:source "~/.authinfo" :host t :protocol t))))
#+end_src

** CRUX --- A Collection of Ridiculously Useful eXtensions            :melpa:

[[https://github.com/bbatsov/crux][A Collection of Ridiculously Useful eXtensions for Emacs]] (CRUX)
provides a number of useful interactive commands that can
improve quality-of-life while using Emacs.

~C-S-j~ is bound to ~crux-top-join-line~ globally, which joins the
current line with the one below it like ~J~ in Vim.

#+name:crux
#+begin_src emacs-lisp
;; useful extensions
(use-package crux)
#+end_src

*** CRUX hydra                                                        :hydra:

Access most of CRUX functionality through a hydra, to reduce
conflicts with global or mode-specific bindings.

#+name: crux-hydra
#+begin_src emacs-lisp
;; hydra for CRUX commands
(defhydra my-hydra/crux (:color teal :columns 3)
  "
CRUX (_q_: quit)"
  ("q" nil nil)
  ("M-o" crux-smart-open-line "newline" :exit nil)
  ("C-M-o" crux-smart-open-line-above "newline-above" :exit nil)
  ("J" crux-top-join-line "join-line" :exit nil)
  ("C-y" crux-duplicate-current-line-or-region "duplicate")
  ("C-;" crux-duplicate-and-comment-current-line-or-region "duplicate+comment")
  ("C" crux-cleanup-buffer-or-region "cleanup-buf/rgn")
  ("R" crux-rename-file-and-buffer "rename-file+buf")
  ("D" crux-delete-file-and-buffer "delete-file+buf")
  ("K" crux-kill-other-buffers "kill-other-bufs")
  ("S" crux-reopen-as-root "sudo-edit")
  ("V" crux-view-url "view-url")
  ("o" crux-open-with "open-external"))
(global-set-key (kbd "C-c C-M-x") #'my-hydra/crux/body)
#+end_src

** Hyperspace launcher for Emacs                                      :melpa:

[[https://github.com/ieure/hyperspace-el][Hyperspace]] is a launcher for Emacs, much like Alfred or Quicksilver
for macOS.

On calling ~hyperspace~, a ~HS:~ prompt will appear in the minibuffer
and the user is expected to provide an input.
The input should be composed of a /keyword/ and an /query/.
The first part of the input (typically the first word) is assumed to be
the keyword, and the remainder of the input is used as the query.

Keywords are mapped to defined actions in ~hyperspace-actions~, which
are either Elisp function symbols or strings.
If the mapped action is an Elisp function symbol, the function is
called with the query as the first argument.
If the mapped action is a string, ~browse-url~ is called with ~(format
ACTION QUERY)~ as the parameter (which typically opens the the
parameter as a URL in the default web browser).

As example, ~ac stuff~ could run the action ~apropos-command~ mapped
to ~ac~ with ~"stuff"~ as the parameter, evaluating the Elisp
expression ~(apropos-command "stuff")~.

As another example, ~g stuff~ could run the action
="https://www.google.com/search?q=%s"= with ~"stuff"~ as the
parameter, opening to the URL
="https://www.google.com/search?q=stuff"= with the default web
browser.

#+name: hyperspace
#+begin_src emacs-lisp
;; launcher for Emacs like Alfred or Quicksilver
;; for example, calling `hyperspace' then "ac stuff"
;; does an apropos command search for "stuff"
(use-package hyperspace
  :demand t
  :init
  (setq hyperspace-actions
        `(("ac" . apropos-command)
          ("af" . (lambda (query) (apropos-command query t)))
          ("av" . apropos-variable)
          ("az" . "https://www.amazon.com/s?k=%s")
          ("bb" . bbdb-search-name)
          ;; TODO : change to https once slow HTTPS queries are fixed in Emacs
          ("e"  . (lambda (query)
                    (eww (format "http://duckduckgo.com/lite?q=%s" query))))
          ("el" . (apply-partially #'hyperspace-action->info "(elisp)Top"))
          ("c"  . "https://anaconda.org/search?q=%s")
          ("d"  . "https://duckduckgo.com/?q=%s")
          ("di" . "https://duckduckgo.com/?q=%s&iax=images&ia=images")
          ("g"  . "https://www.google.com/search?q=%s")
          ("gd" . "https://datasetsearch.research.google.com/search?query=%s")
          ("gm" . "https://maps.google.com/maps?q=%s")
          ("gi" . "https://www.google.com/search?tbm=isch&q=%s")
          ("gt" . "https://trends.google.com/trends/explore?q=%s")
          ("m"  . "https://melpa.org/#/?q=%s")
          ("py" . "https://pypi.org/search/?q=%s")
          ("r"  . "https://www.reddit.com/search.compact?q=%s")
          ("w"  . ,(concat "https://en.wikipedia.org/w/index.php?search=%s"
                           "&title=Special:Search&go=Go"))
          ("y"  . "https://yandex.com/search/?text=%s")
          ("yi" . "https://yandex.com/images/search?text=%s")))
  ;; default action if the keyword of the input is not an action
  ;; comment to use the default setting (first entry of `hyperspace-actions')
  (setq hyperspace-default-action "e")
  :bind (:map hyperspace-minor-mode-map
         ("C-M-S-SPC" . hyperspace))
  :config
  ;; unbind default keys
  (unbind-key "H-SPC" hyperspace-minor-mode-map)
  (unbind-key "<H-return>" hyperspace-minor-mode-map)
  (hyperspace-minor-mode))
#+end_src

** god-mode                                                           :melpa:

[[https://github.com/emacsorphanage/god-mode][god-mode]] is a minor-mode for entering Control and Meta key sequences
without modifier keys.

#+name: god-mode
#+begin_src emacs-lisp
;; minor-mode to input ctrl/meta key sequences without modifier keys
(use-package god-mode
  :bind (("<escape>" . god-mode-all)
         ;; easier window manipulation in god-mode
         ("C-x C-1" . delete-other-windows)
         ("C-x C-2" . split-window-below)
         ("C-x C-3" . split-window-right)
         ("C-x C-0" . delete-window)
         :map god-local-mode-map
         ("." . repeat)
         :map god-mode-isearch-map
         ("<escape>" . god-mode-isearch-disable)
         :map isearch-mode-map
         ("<escape>" . god-mode-isearch-activate))
  :config
  ;; enable in isearch
  (require 'god-mode-isearch)
  ;; use cursor to indicate if in god-mode
  (defun god-mode--update-cursor ()
    "Sets cursor to a box in `god-mode' or read-only buf, else a bar."
    (setq cursor-type (if (or god-local-mode buffer-read-only)
                          'box
                        'bar)))
  (add-hook 'god-mode-enabled-hook #'god-mode--update-cursor)
  (add-hook 'god-mode-disabled-hook #'god-mode--update-cursor)
  ;; enable which-key integration
  (with-eval-after-load 'which-key
    (which-key-enable-god-mode-support)))
#+end_src

** Password management and storage

*** password-store hydra                                              :hydra:

Hydra for password-store.el commands.

#+name: password-store-hydra
#+begin_src emacs-lisp
(when (executable-find "pass")
  ;; hydra for password-store
  (defhydra my-hydra/password-store (:color teal :columns 5
                                     :pre (require 'password-store))
    "
Password store (_q_: quit)"
    ("q" nil nil :exit t)
    ("C" password-store-clear "clear")
    ("c" password-store-copy "copy-pw")
    ("f" password-store-copy-field "copy-field")
    ("e" password-store-edit "edit")
    ("I" password-store-init "init")
    ("i" password-store-insert "insert")
    ("g" password-store-generate "generate")
    ("R" password-store-remove "remove")
    ("r" password-store-rename "rename")
    ("u" password-store-url "url")
    ("v" password-store-version "version"))

  ;; binding for password-store hydra
  (global-set-key (kbd "C-c C-M-S-p") 'my-hydra/password-store/body))
#+end_src

** Help hydra                                                         :hydra:

Hydra for summoning Emacs [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Help.html][help]].

#+name: help-hydra
#+begin_src emacs-lisp
;; hydra for help entrypoints
(defhydra my-hydra/help (:color teal :columns 4)
  "
Help (_q_: quit)"
  ("q" nil nil)
  ("a" apropos-command "apropos-cmd")
  ("d" apropos-documentation "apropos-doc")
  ("f" describe-function "desc-fun")
  ("v" describe-variable "desc-var")
  ("c" describe-key-briefly "desc-key-brief")
  ("k" describe-key "desc-key")
  ("b" describe-bindings "desc-bind")
  ("m" describe-mode "desc-mode")
  ("p" describe-package "desc-pkg")
  ("y" describe-syntax "desc-syntax")
  ("e" view-echo-area-messages "messages")
  ("l" view-lossage "lossage")
  ("i" info "info")
  ("s" info-lookup-symbol "info-symbol")
  ("w" where-is "where-is"))

;; bind help hydra
(global-set-key (kbd "C-c C-M-S-h") 'my-hydra/help/body)
#+end_src

** Auto-disable modes that slow down Emacs in files with long lines

*** Extend buffer hydra with so-long                                  :hydra:

Extend buffer hydra with toggles for ~so-long-mode~ and
~so-long-minor-mode~.

#+name: so-long-hydra
#+begin_src emacs-lisp
(defhydra+ my-hydra/buffer nil
  ("l" so-long-mode "so-long")
  ("L" so-long-minor-mode "so-long-mm"))
#+end_src

** Preserve cursor location

By default, scrolling commands pull the cursor along at the edge.
Setting ~scroll-preserve-screen-position~ to a non-nil symbol that is
not ~t~ configures scrolling to always preserve the cursor location
relative to the top and bottom window boundaries.

#+name: scroll-preserve-screen-position
#+begin_src emacs-lisp
;; preserve cursor vertical window location when scrolling
(setq scroll-preserve-screen-position 'always)
#+end_src

* OS-specific

** macOS

*** load-history-filename-element workaround                     :workaround:

*NOTE*: /[[https://emacsformacosx.com/download/emacs-builds/Emacs-27.1-1.changes][Resolved]] in Emacs for OS X versions 27.1+./

For whatever reason, the ~load-history~ list gets polluted with
symbols in Emacs 27+ on some systems, macOS included (at least for the
Emacs for Mac OS X binary releases), which is probably some issue
around the newly introduced portable dumper.

This causes issues whenever ~load-history-filename-element~ is called,
which can happen pretty often.

One workaround is to redefine ~load-history-filename-element~ to
ignore these problematic entries, although it is unclear if the
problematic entries in ~load-history~ create other issues elsewhere.

See these links:
- [[https://debbugs.gnu.org/db/34/34094.html][GNU bug report logs - #34094]]
- [[https://emacs.stackexchange.com/questions/5552/emacs-on-android-org-mode-error-wrong-type-argument-stringp-require-t][Emacs on Android - org-mode - error - `(wrong-type-argument stringp (require ...) ...)`]]

#+name: mac-load-history-filename-element-workaround
#+begin_src emacs-lisp
;; workaround for problematic entries in `load-history' which affects
;; Emacs 27+ on some systems, probably to do with the portable dumper
;; mainly affecting Emacs for OS X
(when (and (not (version< emacs-version "27"))
           (eq window-system 'ns))
  (defun load-history-filename-element (file-regexp)
    "Get the first elt of `load-history' whose car matches FILE-REGEXP.
Return nil if there isn't one."
    (let* ((loads load-history)
           (load-elt (and loads (car loads))))
      (save-match-data
        (while (and loads
                    (or (null (car load-elt))
                        (not (and (stringp (car load-elt)) ;; skip non-strings
                                  (string-match file-regexp (car load-elt))))))
          (setq loads (cdr loads)
                load-elt (and loads (car loads)))))
      load-elt)))
#+end_src

*** Open Finder at directory of current buffer                        :hydra:

Add a hydra head to the [[Buffer manipulation hydra]] that opens
Finder at the directory of the current buffer.

#+name: mac-open-finder-at-buffer-directory
#+begin_src emacs-lisp
;; add my-hydra/buffer head to open Finder at current buffer directory in macOS
(when (eq system-type 'darwin)
  (defun my-open-finder (&optional path)
    "Opens a new Finder window to PATH if provided,
or the current buffer file or directory if not (macOS)."
    (interactive)
    (let* ((my-path (cl-some 'identity (list path
                                             (buffer-file-name)
                                             default-directory)))
           (my-full-path (expand-file-name my-path))
           (my-process-args (list "my-open-finder" nil
                                  "open" "-R" my-full-path)))
      (if (eq system-type 'darwin)
          (apply 'start-process my-process-args)
        (message "my-open-finder is macOS-only"))))
  (defhydra+ my-hydra/buffer nil
    ("e" my-open-finder "open-finder" :exit t)))
#+end_src

*** Ligatures in Emacs Mac Port                                       :hydra:

The [[https://bitbucket.org/mituharu/emacs-mac/][Emacs Mac Port]] ([[https://github.com/railwaycat/homebrew-emacsmacport/releases][binaries]]) by Mitsuharu Yamamoto has built-in support for
font ligatures with its ~mac-auto-operator-composition-mode~.
Add a head to the visual settings hydra for toggling this built-in support.

#+name: mac-emacs-mac-port-hydra-toggle-ligatures
#+begin_src emacs-lisp
;; enable toggling of ligatures in visual hydra when using emacs-mac port
(when (fboundp 'mac-auto-operator-composition-mode)
  (defhydra+ my-hydra/visual nil
    ("L" mac-auto-operator-composition-mode "toggle-ligature" :exit nil)))
#+end_src

If using [[https://emacsformacosx.com/][Emacs for Mac OS X]], use the built-in [[https://github.com/emacs-mirror/emacs/blob/master/lisp/progmodes/prog-mode.el#L199-L238][Prettify Symbols mode]] and modify ~prettify-symbols-alist~ to configure the desired character compositions.
* Transient commands

** Global transients

*** Neuron transient

Transient for interfacing with neuron Zettelkasten.

#+name: neuron-transient
#+begin_src emacs-lisp
;; add transient for neuron commands, bind to "C-c C-M-z"
(with-eval-after-load 'neuron-mode
  (transient-define-prefix transient/neuron ()
    "Neuron Zettelkasten commands."
    ["Neuron Zettelkasten"
     ["File"
      ("z" "New" neuron-new-zettel)
      ("e" "Edit" neuron-edit-zettel)
      ("j" "Daily" neuron-open-daily-notes)
      ("o" "Open" neuron-open-zettel)
      ("i" "Open index" neuron-open-index)
      ]
     ["Server"
      ("rw" "Watch files" neuron-rib-watch)
      ("rg" "Generate site" neuron-rib-generate)
      ("rs" "Start" neuron-rib-serve)
      ("ro" "Open" neuron-rib-open-zettel)
      ("ri" "Open z-index" neuron-rib-open-z-index)
      ("rk" "Kill" neuron-rib-kill)
      ]
     ["Other"
      ("t" "Query tags" neuron-query-tags)
      ("g" "Refresh cache" neuron-refresh)
      ("c" "Configuration" neuron-edit-zettelkasten-configuration)
      ]
     ]
    )
  (global-set-key (kbd "C-c C-M-z") #'transient/neuron))
#+end_src
*** Symbol overlay transient

Add transient popup for symbol-overlay functionality.

#+name: symbol-overlay-transient
#+begin_src emacs-lisp
;; add symbol-overlay transient popup and bind to "C-:"
(with-eval-after-load 'symbol-overlay
  (transient-define-prefix transient/symbol-overlay ()
    "Symbol overlay commands"
    ;; suffix actions don't exit the transient popup by default
    :transient-suffix 'transient--do-stay
    ["Symbol overlays"
     ["Navigation"
      ("n" "Jump next" symbol-overlay-jump-next)
      ("p" "Jump prev" symbol-overlay-jump-prev)
      ("f" "Switch fwd" symbol-overlay-switch-forward)
      ("b" "Switch bwd" symbol-overlay-switch-backward)
      ]
     ["Operations"
      ("i" "Put/Remove" symbol-overlay-put)
      ("t" "Toggle scope" symbol-overlay-toggle-in-scope)
      ("k" "Remove all" symbol-overlay-remove-all :transient nil)
      ("r" "Rename" symbol-overlay-rename :transient nil)
      ("q" "Query/Replace" symbol-overlay-query-replace :transient nil)
      ]
     ["Other"
      ("m" (lambda () (transient--make-description
                       "symbol-overlay-mode"
                       symbol-overlay-mode))
       symbol-overlay-mode)
      ("w" "Copy" symbol-overlay-save-symbol)
      ("s" "Search" symbol-overlay-isearch-literally :transient nil)
      ("d" "Defn" symbol-overlay-jump-to-definition :transient nil)
      ]
     ]
    )
  (global-set-key (kbd "C-:") 'transient/symbol-overlay))
#+end_src

** Major mode transients

*** neuron-mode transient

Neuron major mode transient.

#+name: neuron-mode-transient
#+begin_src emacs-lisp
;; major-mode specific transient for neuron-mode
(with-eval-after-load 'neuron-mode
  (transient-define-prefix transient/neuron-mode ()
    "`neuron-mode' commands."
    ["Neuron mode"
     ["File"
      ("o" "Follow at point" neuron-follow-thing-at-point)
      ("u" "Edit uplink" neuron-edit-uplink)
      ("r" "Open current" neuron-open-current-zettel)
      ]
     ["Tags"
      ("t" "Add" neuron-add-tag)
      ("T" "Add (multiple)" neuron-add-tags)
      ]
     ["Insert"
      ("l" "Zettel link" neuron-create-and-insert-zettel-link)
      ("L" "Zettel link from region" neuron-create-zettel-from-selected-title)
      ("s" "Static link" neuron-insert-static-link)
      ]
     ]
    [
     ["Other"
      ("c" "Toggle link conn type" neuron-toggle-connection-type :transient nil)
      ("m" "Markdown major mode transient" transient/markdown-mode)
      ]
     ]
    )
  (define-key neuron-mode-map (kbd "C-c C-M-m") #'transient/neuron-mode))
#+end_src

** Minor mode transients

*** flycheck-mode transient

Flycheck minor mode transient.

#+name: flycheck-mode-transient
#+begin_src emacs-lisp
;; add transient for Flycheck
(with-eval-after-load 'flycheck
  (defun transient/flycheck-mode--close-error-list ()
    "Close the Flycheck error list window if it is shown."
    (interactive)
    (quit-windows-on "*Flycheck errors*" t))
  (transient-define-prefix transient/flycheck-mode ()
    "`flycheck-mode' commands."
    :transient-suffix 'transient--do-stay
    [:description (lambda ()
                    (transient--make-description
                     "Flycheck"
                     flycheck-mode))
     ["Error"
      ("n" "Next" flycheck-next-error)
      ("p" "Previous" flycheck-previous-error)
      ("l" "List open" flycheck-list-errors)
      ("L" "List close" transient/flycheck-mode--close-error-list)
      ("H" "Local help at point" display-local-help)
      ("h" "Display at point" flycheck-display-error-at-point)
      ("e" "Explain at point" flycheck-explain-error-at-point)
      ("C-w" "Copy all" flycheck-copy-errors-as-kill)
      ("C" "Clear all" flycheck-clear)
      ]
     ["Checker"
      ("s" "Select" flycheck-select-checker)
      ("?" "Describe" flycheck-describe-checker :transient nil)
      ("c" "Run" flycheck-buffer)
      ("C-c" "Run via `compile'" flycheck-compile)
      ]
     ["Other"
      ("v" "Verify setup" flycheck-verify-setup :transient nil)
      ("i" "Online manual" flycheck-manual :transient nil)
      ("m" "Toggle mode" flycheck-mode)
      ]
     ]
    )
  (global-set-key (kbd "C-c F") #'transient/flycheck-mode))
#+end_src

*** ejc-sql-mode transient

ejc-sql minor mode transient.

#+name: ejc-sql-mode-transient
#+begin_src emacs-lisp
;; add transient for ejc-sql
(with-eval-after-load 'ejc-sql
  ;; interactive versions of ejc-sql output customization functions
  (defun transient/ejc-sql-mode--set-fetch-size (n)
    "Interactive version of `ejc-set-fetch-size'."
    (interactive "NEnter fetch size (num records to output): ")
    (ejc-set-fetch-size n))
  (defun transient/ejc-sql-mode--set-max-rows (n)
    "Interactive version of `ejc-set-max-rows'."
    (interactive "NEnter max rows (RecordSet num row limit): ")
    (ejc-set-max-rows n))
  (defun transient/ejc-sql-mode--set-column-width-limit (n)
    "Interactive version of `ejc-set-column-width-limit'."
    (interactive "NEnter column width limit: ")
    (ejc-set-column-width-limit n))

  (transient-define-prefix transient/ejc-sql-mode ()
    "`ejc-sql-mode' commands."
    ["ejc-sql"
     ["Session"
      ("c" "Connect" ejc-connect)
      ("i" "Connect-i" ejc-connect-interactive)
      ("C-l" "Log" ejc-open-log)
      ("q" "Quit" ejc-quit-connection)
      ]
     ["Show"
      ("M-," "Prev result" ejc-show-prev-result :transient t)
      ("<up>" "Result buffer" ejc-show-last-result)
      ("t" "Tables list" ejc-show-tables-list)
      ("v" "Views list" ejc-show-views-list)
      ("p" "Procedures list" ejc-show-procedures-list)
      ("T" "User types list" ejc-show-user-types-list)
      ("C" "Constraints list" ejc-show-constraints-list)
      ]
     ["Format"
      ("f" "Pprint" ejc-format-sql-at-point)
      ("F" "Pprint region" ejc-format-sql-region)
      ("s" "Strip SQL" ejc-strinp-sql-at-point)
      ("S" "Dress SQL" ejc-dress-sql-at-point)
      ]
     ["Other"
      ("b" "Temp buffer" ejc-get-temp-editor-buffer)
      ("of" "Fetch size" transient/ejc-sql-mode--set-fetch-size)
      ("or" "Max rows" transient/ejc-sql-mode--set-max-rows)
      ("oc" "Col width" transient/ejc-sql-mode--set-column-width-limit)
      ]
     ]
    [
     ["Navigate"
      ("M-b" "Previous" ejc-previous-sql :transient t)
      ("M-f" "Next" ejc-next-sql :transient t)
      ]
     ["Run"
      ("C-c" "Statement" ejc-eval-user-sql-at-point)
      ("C-r" "Region" ejc-eval-user-sql-region)
      ]
     ["Describe"
      ("ht" "Describe table" ejc-describe-table)
      ("hd" "Describe entity" ejc-describe-entity)
      ("hs" "Database structure" ejc-direx:pop-to-buffer)
      ]
     ]
    )
  (global-set-key (kbd "C-c q") #'transient/ejc-sql-mode))
#+end_src

* Backlog

** Command-line interaction

*** [#C] native-complete and company-native-complete

[[https://github.com/CeleritasCelery/emacs-native-shell-complete][GitHub - CeleritasCelery/emacs-native-shell-complete: Completion in shell buffer]]

** Editing text

*** [#C] objed

[[https://github.com/clemera/objed][GitHub - clemera/objed: Navigate and edit text objects with Emacs]]

** Non-programming files

*** Nix configuration files

**** [#C] nix-mode for editing Nix configuration files                :melpa:

[[https://github.com/NixOS/nix-mode][GitHub - NixOS/nix-mode: An Emacs major mode for editing Nix expressions.]]

**** [#C] nix-update-el for updating the rev/sha of a fetchgit declaration :melpa:

[[https://github.com/jwiegley/nix-update-el][GitHub - jwiegley/nix-update-el]] ([[https://melpa.org/#/nix-update][MELPA]])

** Org-mode

*** [#B] Org-ref                                                      :melpa:

[[https://github.com/jkitchin/org-ref][Org-ref]] is a collection of modules for managing citations, references
and BibTeX bibliographies in Org-mode.

** Project interaction

*** [#C] nix-buffer for directory/file-specific specific environments :external:melpa:

[[https://github.com/shlevy/nix-buffer][nix-buffer]] allows for directory-specific or file-specific (see below)
environments using Nix.

- Using nix-buffer for file-local environments ([[https://blog.jethro.dev/posts/nix_buffer_emacs/][link]])

** Search

*** [#B] CTRLF for better-behaved search

[[https://github.com/raxod502/ctrlf][CTRLF]] is a replacement for Isearch (alternatives are [[https://github.com/abo-abo/swiper][Swiper]] and
[[https://github.com/emacsorphanage/helm-swoop][helm-swoop]]) but has more consistent behavior (e.g. ~C-g~ always
cancels search where in Isearch its behavior depends on the search
state, ~C-s~ has to be pressed twice after the last search to wrap
around, and so on) and some nicer bindings (~M-<~ and ~M->~ go to the
first and last matches).

** Web

*** [#C] org-static-blog                                              :melpa:

[[https://github.com/bastibe/org-static-blog][org-static-blog]] is a static website generator.

It integrates well with Github pages or GitLab pages.

It is possible to set up auto-rendering using CI tooling a new blog
post is pushed, see [[https://gitlab.com/_zngguvnf/org-static-blog-example][here]].

To enable local development, may want to use a =.dir-locals= file in
the repository that sets up a switcher between local development and
remote deployment for:
- ~org-static-blog-publish-url~
- ~org-static-blog-publish-directory~
- ~org-static-blog-posts-directory~
- ~org-static-blog-drafts-directory~

References:
- [[https://jao.io/blog/2020-02-11-simplicity.html][simplicity]]
- [[https://favicon.io/emoji-favicons/floppy-disk/][Floppy Disk | Favicon.io]] (for favicon)

An alternative is to use the built-in Org publish facilities. See [[https://www.evenchick.com/blog/blogging-with-org-mode.html][here]]
and [[https://ogbe.net/blog/blogging_with_org.html][here]] for more information. This is a bit more work, especially the
RSS setup, but does not require adding another package dependency.

